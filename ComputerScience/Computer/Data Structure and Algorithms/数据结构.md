# 1.复杂度

大纲：

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1667910338624-02753346-9bff-4212-9333-3276ea46b49d.png)

时间复杂度：估算程序的执行次数（执行时间）

常见的时间复杂度估算方法——大O表示法

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1667953955353-64a8545a-ae50-48d0-b46f-5ef14d180234.png)

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1667953891010-597009c9-27d5-4831-84d0-4e858f49972f.png)

响应时间复杂度的执行效率：

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1667954247648-b928c34d-9978-4d0e-8eb2-5a13faa7593d.png)

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1667954274604-5bb7b147-9833-4462-979a-ecda01b2c307.png)

  

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1667954151672-c627c1e2-e0f0-4e07-b3d8-0d84b0b90b70.png)

# 2.动态数组

## 2.1 数组（Array）

- 数组是一种顺序存储的线性表, 所有元素的内存地址都是连续的。

```
int[] array = new int[]{11, 22, 33} 
```

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965104173-74ef8f1a-7f7b-40f7-b2e2-fcee8f632171.webp)

- 在很多编程语言中，数组有个致命的缺点， **无法动态修改容量**。
- 实际开发中我们希望数组的容量是**动态变化**的。

## 2.2 动态数组（Dynamic Array）接口设计

- 创建ArrayList类，创建size属性来管理数组中元素的个数， 创建elements属性来管理存取的数据。
- 可以对动态数组进行增删改查操作。

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965104214-172e8f49-edfe-4463-8110-875debbdf345.webp)

```
public class ArrayList<E> {
    private int size;
    private E[] elements;

    // 元素的数量
    int size(); 
    // 是否为空
    boolean isEmpty();
    // 是否包含某个元素
    boolean contains(E element); 
    // 添加元素到最后面
    void add(E element); 
    // 返回index位置对应的元素
    E get(int index); 
    // 设置index位置的元素
    E set(int index, E element); 
    // 往index位置添加元素
    void add(int index, E element); 
    // 删除index位置对应的元素 
    E remove(int index); 
    // 查看元素的位置
    int indexOf(E element); 
    // 清除所有元素
    void clear(); 
}
```

## 2.3 动态数组的实现

### 2.3.1 构造方法

- 如果构建的数组空间小于默认空间，则会以默认空间构建数组。

```
public class ArrayList<E> {
    private int size;
    private E[] elements;
    // 设置elements数组默认的初始化空间
    private static final int CAPACITY_DEFAULT = 10;
	
    public ArrayList(int capacity) {
        capacity = capacity < CAPACITY_DEFAULT ? CAPACITY_DEFAULT : capacity;
        elements = (E[]) new Object[capacity];
    }
	
    // 便利构造器
    public ArrayList() {
        this(CAPACITY_DEFAULT);
    }
}
```

### 2.3.2 添加元素

- 数组添加元素分为在最后一个元素的后面添加新元素和将元素插入到某个位置（非最后面）两种情况。
- 第一种情况，这个新元素需要添加到的索引等于当前数组元素的个数，在ArrayList中size属性就是当前数组元素的个数，所以就是将新元素添加到数组的size位置上，然后size加1。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965104347-9e79fb53-809a-4daf-bd80-9cfb08a6ccd9.webp)

```
public void add(int index, E element) {
    elements[index] = element;
    size++;
}
```

- 如果是第二种情况，只需要将插入位置后面的元素向后移动即可。
- 注意：需要从后向前移动元素，如果从前向后移动元素，那么会进行元素覆盖, 最后出错。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965104195-4f937b34-31ef-4752-844d-de2bab133776.webp)

#### 数组越界

- 添加元素，还要注意传入的索引不能越界，即不能小于0, 也不能大于size。

```
private void rangeCheckForAdd(int index) {
    if (index < 0 || index > size) {
        outOfBounds(index);
    }
}
```

#### 数组扩容

- 由于数组elements最大的容量只有10，所以当数组存满元素时，就需要对数组进行扩容。
- 因为数组是无法动态扩容的，所以需要创建一个新的数组，这个数组的容量要比之前数组的容量大。
- 然后在将原数组中的元素存放到新数组中，这样就实现了数组的扩容。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965104175-b0ce0b5c-4d2d-4a12-aeac-6fa2d0080623.webp)

```
private void ensureCapacity(int capacity) {
    // 获取数组当前容量
    int oldCapacity = elements.length;
    // 如果 当前存储的元素个数 < 当前数组容量, 直接返回
    if (capacity <= oldCapacity) return;
    // 新数组的容量为原数组容量的1.5倍
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    // 创建新数组
    E[] newElements = (E[]) new Object[newCapacity];
    // 原数组中的元素存储到新数组中
    for (int i = 0; i < size; i++) {
    	newElements[i] = elements[i];
    }
    // 引用新数组
    elements = newElements;
}
```

- 实现add函数，需要在添加新元素之前，判断数组越界和扩容。

```
public void add(int index, E element) {
    //判断越界
    rangeCheckForAdd(index);
    //判断扩容，size+1表示这次扩容之后size	    	
    ensureCapacity(size + 1);
    	
    for (int i = size - 1; i >= index; i--) {
        elements[i + 1] = elements[i];
    }
    elements[index] = element;
    size++;
}
```

- 最终在最后一个元素的后面添加新元素，即添加元素到尾部的实现方式如下

```
public void add(E element) {
    add(size, element);
}
```

### 2.3.3 删除元素

- 删除元素，实际上就是去掉指定位置的元素，并将后面的元素向前移动。
- 如下图，当删除索引为3的元素时，只需要将后面的元素向前移动，然后在去掉最后一个元素，size减1即可。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965105527-5e4861e5-ec05-4e63-85e7-13c82d57cc6f.webp)

#### 数组越界

- 删除元素时传入的索引不能越界, 即不能小于0, 也不能大于等于size 所以我们在删除元素之前需要先进行索引检查。

```
private void outOfBounds(int index) {
    throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);
}
	
private void rangeCheck(int index) {
    if (index < 0 || index >= size) {
        outOfBounds(index);
    }
}
```

#### 数组缩容

- 当数组中的元素删除后，数组剩余的空间可能会很大，这样就会造成内存的浪费。
- 所以当数组中元素删除后，我们需要对数组进行缩容。
- 实现方法类似于扩容，当数组中容量小于某个值时，创建新的数组，然后将原有数组中的元素存入新数组即可。

```
public void trim() {
    // 获取当前数组的容量
    int capacity = elements.length;
    // 当size大于等于容量的一半, 或则容量已经小于默认容量(10)时, 直接返回
    if (size >= capacity >> 1 || capacity < CAPACITY_DEFAULT) return;
    // 计算新的容量 = 原有容量的一半
    int newCapacity = capacity >> 1;
    // 创建新数组
    E[] newElements = (E[]) new Object[newCapacity];
    // 将原数组元素存入新数组
    for (int i = 0; i < size; i++) {
    	newElements[i] = elements[i];
    }
    // 引用新数组
    elements = newElements;
}
```

- 最终, remove方法实现如下

```
public E remove(int index) {
    // 判断索引是否越界
    rangeCheck(index);
    // 取出需要删除的元素
    E old = elements[index];
    // 通过循环, 将index后面的所有元素向前移动一位
    for (int i = index + 1; i < size; i++) {
        elements[i - 1] = elements[i];
    }
    // 删除最后一个元素
    elements[--size] = null;
    // 判断数组是否需要缩容
    trim();
    // 将删除的元素返回
    return old;
}
```

### 2.3.4 清空数组

- 清空数组时，需要将所有的元素置为null，只有这样才能真正的释放对象，然后size置为0。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965105592-846a267f-70ad-4a72-9186-35157107fd1e.webp)

```
public void clear() {
    // 清空存储的数据
    for (int i = 0; i < size; i++) {
        elements[i] = null;
    }
    // 将size置为0
    size = 0;
}
```

### 2.3.5 修改元素

- 修改元素时，只需要将原有位置的元素替换掉即可，同样需要注意一下索引是否越界。

```
public E set(int index, E element) {
    // 判断索引是否越界
    rangeCheck(index);
    // 取出被替换元素
    E oldElement = elements[index];
    // 替换元素
    elements[index] = element;
    // 返回被替换元素
    return oldElement;
}
```

### 2.3.6 查询元素

- 查询元素，只需要将指定索引的元素返回，注意索引是否越界即可。

```
public E get(int index) {
    rangeCheck(index);
    return elements[index];
}
```

### 2.3.7 查看元素位置

- 可以通过循环, 查找元素在数组中的位置。
- 注意：假如数组中可以存储null，而null是不能调用equals方法的，所以需要对传入的元素进行判断，如果查找的元素是null，需要单独处理。
- 当元素存在时返回索引，否则返回变量ELEMENT_ON_FOUND的值。

```
private static final int ELEMENT_NOT_FOUND = -1;
public int indexOf(E element) {
    if (element == null) {
        for (int i = 0; i < size; i++) {
            if (elements[i] == null) return i;
        }
    } else {
        for (int i = 0; i < size; i++) {
            if (element.equals(elements[i])) return i;
        }
    }
    return ELEMENT_NOT_FOUND;
}
```

### 2.3.8 是否包含某元素

- 只需通过判断索引是否等于ELEMENT_ON_FOUND即可。

```
public boolean contains(E element) {
    // 查看元素的索引是否为ELEMENT_ON_FOUND即可
    return indexOf(element) != ELEMENT_ON_FOUND;
}
```

### 2.3.9 元素的数量

- size的值，即为元素的数量。

```
public int size() {
    return size;
}
```

### 2.3.10 数组是否为空

- 通过判断size的值是否为0即可。

```
public boolean isEmpty() {
    return size == 0;
}
```

### 2.3.11 动态数组打印

- 可以重写toString方法, 来打印ArrayList中的元素。

```
@Override
public String toString() {
    StringBuilder string = new StringBuilder();
    string.append("size = ").append(size).append(", [");
    for (int i = 0; i < size; i++) {
        if (i != 0) {
            string.append(",");
        }
        string.append(elements[i]);
    }
    string.append("]");
    return string.toString();
}
```

到此为止，我们成功的实现了动态数组。

## 2.4 动态数组的复杂度

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965105633-74f2bd7d-86fe-40cf-a18f-a02935286a44.webp)

## 2.5 ArrayList能否进一步优化？

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965105662-25c503e8-42ac-4f2e-9d99-4cb67699e3c5.webp)

- 在ArrayList中，如果要删除索引0位置的元素，则需要将索引0之后的元素全部往前移一位。
- 如果要在索引0位置添加元素，也需要将索引0及之后的元素全部往后移一位。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965105680-215317ce-acb8-400a-99f1-f2d24a31ac9f.webp)
- 在ArrayList中增加一个记录首元素位置的属性。
- 删除索引0位置的元素，我们只需要将first属性改为1。
- 在索引0位置添加元素，则只需要将first属性改为0。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965106392-c2234af5-fa4a-42c8-b22c-077fc3c38cca.webp)
- 如果继续往前插入元素，则将插入的元素存放在索引8这个位置，并将first改为8。
- 当要获取索引8下一个元素时，对索引取模，则拿到索引0位置的元素。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667965106477-57d5a635-619e-4438-adfe-7952e7a90465.webp)
- 如果插入元素，则可选择挪动前半段数据或后半段数据。
- 在索引2处插入元素99，可以选择将元素22，33左移，然后插入99即可。
- 扩容和缩容同样可以优化。

# 3.链表

## 3.1 链表（LinkedList）

- 链表是一种链式存储的线性表, 所有元素的内存地址不一定是连续的。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667980270207-62d0794c-3b01-4d31-9ca3-660cedef7570.webp)

## 3.2 链表（LinkedList）接口设计

- 创建LinkedList类，用来管理链表数据，其中的size属性记录存储数据的数量，first属性引用链表的第0个元素。
- 创建私有类Node，其中的element属性用于存储元素，next属性用于指向链表中的下一个节点。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667980270307-aa401905-5033-408d-91ab-a1551275a9e5.webp)

LinkedList是作为Node对象链的头，而不是将数据存储在LinkedList对象里面，只是持有一个指针（下一个Node对象的内存地址），Node对象才存储数据。Node只是在LinkedList内部使用，所以将Node对象设计成内部类。

```
public class LinkedList<E> {
    private int size;
    private Node<E> first;
    
    // 元素的数量
    int size(); 
    // 是否为空
    boolean isEmpty();
    // 是否包含某个元素
    boolean contains(E element); 
    // 添加元素到最后面
    void add(E element); 
    // 返回index位置对应的元素
    E get(int index); 
    // 设置index位置的元素
    E set(int index, E element); 
    // 往index位置添加元素
    void add(int index, E element); 
    // 删除index位置对应的元素 
    E remove(int index); 
    // 查看元素的位置
    int indexOf(E element); 
    // 清除所有元素
    void clear();
    
    // 私有类, 链表中的节点
    private class Node<E> {
        E element;
        Node<E> next;
        // 构造方法
        public Node(E element, Node<E> next) {
            this.element = element;
            this.next = next;
        }
    }
}
```

## 3.3 链表的实现

### 3.3.1 构造方法

- 链表的创建与动态数组不同，动态数组在构造时需要传入一个空间属性，来决定这个数组的容量。但链表元素是在添加时才创建的，内存地址不一定是连续的。所以链表不需要在单独设计构造方法，使用默认构造方法即可。

### 3.3.2 添加元素

- 添加数据时，需要创建一个节点存储数据，并将该节点拼接到最后节点的后面，然后size加1。
- 需要区分当前链表没有数据，新节点拼接到first和当前链表有数据，新节点拼接到最后的节点。

```
public void add(E element) {
    // 当first等于null时, 说明此事没有节点, 所以first引用新节点
    if (first == null) {
    	first = new Node<E>(element, null);
    }
    // 当fitst不等于null时, 说明链表中有节点, 此时获取最后一个节点, 并将该节点的next指向新节点
    else {
        Node<E> node = node(size - 1);
        node.next = new Node<E>(element, null);
    }
    size++;
}
```

### 3.3.3 插入元素

- 插入链表，首先需要创建新节点，然后通过变更插入位置前一个元素next指针指向，插入指定位置即可。
- 需要区分插入到0的位置，使用first指向新节点和插入到非0位置，找到前一个节点进行处理两种情况。

#### 数组越界

- 插入元素的位置必须不能小于0, 也不能大于等于size，所以我们在插入元素之前需要先进行索引检查。

```
protected void outOfBounds(int index) {
    throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);
}
	
protected void rangeCheck(int index) {
    if (index < 0 || index >= size) {
        outOfBounds(index);
    }
}
```

- 插入元素代码如下：

```
public void add(int index, E element) {
    // 检查索引是否越界
    rangeCheckForSize(index);
    // 当插入到0的位置时
    if (index == 0) {
        // 将first指向新节点, 新节点的next指向first之前指向的节点
        first = new Node<E>(element, first.next);
    }else {
        // 找到指定位置前面的节点
        Node<E> prev = node(index - 1);
        // 将前面节点的next指向新节点, 新节点的next指向prev之前指向的节点
        prev.next = new Node<>(element, prev.next);
    }
    size++;
}
```

- 添加元素也可以简写：

```
public void add(E element) {
    // 元素添加到size位置, 即添加到最后面
    add(size, element);
}
```

### 3.3.4 删除元素

- 首先找到删除节点(delete_node)的前一个节点(pre_node)，然后通过变更(pre_node)节点next指针指向删除节点(delete_node)的下一个节点即可，然后size减1。
- 需要判断是否删除的第0个元素，如果是，则使用first指向第1个节点。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667980270213-873892de-fcbd-4b18-8c24-8c875a4e8d44.webp)

```
public E remove(int index) {
    // 检查索引是否越界
    rangeCheck(index);
    // 记录需要删除的节点
    Node<E> old = first;
    // 当删除第0个元素时, 将first的next指向索引为`1`的节点即可
    if (index == 0) {
        first = first.next;
    }else {
        // 找到前一个元素
        Node<E> prev = node(index - 1);
        // 记录需要删除的节点
        old = prev.next;
        // 将prev的next指向需要删除节点的后一个节点
        prev.next = old.next;
    }
    // size-1
    size--;
    // 返回删除的元素
    return old.element;
}
```

### 3.3.5 清空元素

- 将first指向null，释放链表所有node，同时size置为0即可。

```
public void clear() {
    first = null;
    size = 0;
}
```

### 3.3.6 修改元素

- 首先通过遍历链表元素，找到该节点。

```
private Node<E> node(int index) {
    //越界判断
    rangeCheck(index);
		
    Node<E> node = first;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
    return node;
}
```

- 然后修改node节点的element即可。

```
public E set(int index, E element) {
    // 找到对应节点, node方法中已经判断了索引是否越界
    Node<E> node = node(index);
    // 记录旧元素
    E old = node.element;
    // 覆盖元素
    node.element = element;
    // 返回旧元素
    return old;
}
```

### 3.3.7 查找元素

- 找到对应的节点, 取出元素即可。

```
public E get(int index) {
    // node方法中已经判断了索引是否越界
    return node(index).element;
}
```

### 3.3.8 查找元素索引

- 查找指定元素的索引，需要遍历所有节点，找到节点对应的元素与执行元素相等即可。
- 如果需要支持节点element为null，则需要分两种情况处理。

```
private static final int ELEMENT_ON_FOUND = -1;
public int indexOf(E element) {
    // 取出头结点
    Node<E> node = first;
    // 当element为null时的处理
    if (element == null) {
        // 遍历节点, 找到存储为null的节点, 返回索引
        for (int i = 0; i < size; i++) {
            if (node.element == null) return i;
            node = node.next;
        }
    }else {
        for (int i = 0; i < size; i++) {
            // 遍历节点, 找到存储的元素与指定元素相等的节点, 返回索引
            if (element.equals(node.element)) return i;
            node = node.next;
        }
    }
    // 没有找到元素对应的节点, 返回ELEMENT_ON_FOUND
    return ELEMENT_ON_FOUND;
 }
```

### 3.3.9 获取链表存储元素的个数

- 获取链表存储元素的个数, 就是size的值。

```
public int size() {
    return size;
}
```

### 3.3.10 链表是否为空

- 链表是否为空, 只需要判断size是否等于0即可。

```
public boolean isEmpty() {
    return size == 0;
}
```

### 3.3.11 判断元素是否存在

- 判断元素是否存在, 只需要判断元素的索引是否为ELEMENT_ON_FOUND即可。

```
public boolean contains(E element) {
    return indexOf(element) != ELEMENT_ON_FOUND;
}
```

### 3.3.12 打印链表中存储的数据

```
public String toString() {
    StringBuilder string = new StringBuilder();
    string.append("size = ").append(size).append(", [");
    Node<E> node = first;
    for (int i = 0; i < size; i++) {
        if (i != 0) {
            string.append(",");
        }
        string.append(node.element);
        node = node.next;
    }
    string.append("]");
    return string.toString();
}
```

到此为止，我们成功的实现了链表。

## 3.4 链表的复杂度

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1667980270289-c414c5f9-d0c3-4ea6-9f19-21458252b617.webp)

## 3.5 leetcode算法题

#### 1、[删除链表中的节点](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fdelete-node-in-a-linked-list%2F)

#### 2、[反转链表](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Freverse-linked-list%2F)

#### 3、[环形链表](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Flinked-list-cycle%2F)

#### 4、[移除链表元素](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fremove-linked-list-elements%2F)

#### 5、[删除排序链表中的重复元素](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fremove-duplicates-from-sorted-list%2F)

#### 6、[链表的中间结点](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fmiddle-of-the-linked-list%2Fsolution%2F)

# 4.双向链表

### 一、双向链表

- [单向链表](https://juejin.cn/post/6844904023208771591)只能通过Node中next属性从头遍历链表，完成搜索。
- 双向链表中的Node增加prev属性，指向该节点上一个节点。
- 双向链表查找元素可以从first或last两个方向开始查找。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668746408747-af20a76d-3d38-48c6-8c93-9162cd7e7986.png)

### 二、双向链表接口设计

- 相较于单项链表，双向链表需要重写查找节点、插入节点、删除节点、清空节点四个方法。

### 三、双向链表的实现

#### 1、构造方法

- 在双向链表属性中增加last属性记录尾节点。在Node属性中增加prev属性记录上一个节点。

```
public class LinkedList<E> extends AbstractList<E> {    
    private Node<E> first;
    //增加last节点
    private Node<E> last; 
	
    private static class Node<E> {
        E element;
        //增加上一个节点
        Node<E> prev; 
        Node<E> next;
        public Node(Node<E> prev, E element, Node<E> next) {
            this.prev = prev;
            this.element = element;
            this.next = next;
        }
    }
}
```

#### 2、查找节点

- 通过判断查找的节点在链表的前半段或后半段，选择first节点从前往后遍历或last节点从后往前遍历。

```
private Node<E> node(int index) {
    rangeCheck(index);
		
    // 判断节点是在链表前一半还是后一半
    if (index < (size >> 1)) {
        Node<E> node = first;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    } else {
        Node<E> node = last;
        for (int i = size - 1; i > index; i--) {
            node = node.prev;
        }
        return node;
    }
}
```

#### 3、清空节点

- 需将新增属性last置为null。

```
public void clear() {
    size = 0;
    first = null;
    last = null;
}
```

#### 4、插入节点

- 插入位置原节点为old_node（下图2号节点），上一个节点为pre_node（下图1号节点），新节点为new_node。
- pre_node的next现在为new_node。
- old_node的prev现在为new_node。
- new_node的prev即为old_node的prev。
- new_node的next为old_node。
- 特殊情况，插入在最前面：

- 如果old_node的prev为null，那么old_node即为原头节点。那么双向链表的first属性需改为new_node。

- 插入在最后面：

- new_node的prev为双向链表的last，next为null，同时last属性需改为new_node。
- 如果原链表为空，则双向链表的first和last都为new_node。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668746408788-5236e60b-ecd8-4b97-8759-b3db40f9c32b.png)

```
public void add(int index, E element) {
    rangeCheckForAdd(index);

    // 往最后面添加元素
    if (index == size) { 
        Node<E> oldLast = last;
        last = new Node<>(oldLast, element, null);
        // 这是链表添加的第一个元素
        if (oldLast == null) {  
            first = last;
        } else {
            oldLast.next = last;
        }
    } else {
        //插入位置的原节点，即为新节点的next节点。
        Node<E> next = node(index); 
        //新添加节点的上一个节点，即为该位置原节点的上一个节点。
        Node<E> prev = next.prev; 
        //创建新添加节点。
        Node<E> node = new Node<>(prev, element, next);
        //原节点的上一个节点，为新添加节点。
        next.prev = node;
        // index == 0
        if (prev == null) { 
            first = node;
        } else {
            //原节点上一个节点的next，即为新添加节点。
            prev.next = node;
        }
    }
    size++;
}
```

#### 5、删除节点

- 删除节点, 只需要让被删除节点的前一个节点与后一个节点之间链接, 同时去掉被删除节点引用即可。
- 需要注意的是, 第0个节点和最后一个节点要特殊处理。

```
public E remove(int index) {
    // 需要删除的节点
    Node<E> node = node(index);
    // 删除节点的前一个节点
    Node<E> prev = node.prev;
    // 删除节点的后一个节点
    Node<E> next = node.next;	
    // 删除节点, 只需要去掉对这个节点的引用即可
    // 如果prev == null, 说明删除的是第一个节点
    if (prev == null) {
    	first = next;
    }else {
    	prev.next = next;
    }
    // 如果next == null, 说明删除的是最后一个节点
    if (next == null) {
    	last = prev;
    }else {
    	next.prev = prev;
    }
    size--;
    return node.element;
}
```

#### 6、清空节点

- 清空节点, 需要将first和last的引用全部断开。

```
public void clear() {
    size = 0;
    first = null;
    last = null;
}
```

到此为止，我们即完成了从单向链表到双向链表的改造。

### 四、双向链表vs动态数组

# 5.循环链表

### 一、单向循环链表

- 尾节点的next，指向头节点。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668760980882-4baedb62-b8da-4f07-a7bf-42e3f5b4f79d.png)

### 二、单向循环链表接口设计

- 相较于单项链表，单向循环链表需要重写插入节点、删除节点两个方法。

### 三、单向循环链表的实现

#### 1、插入节点

- 插入节点，需要特别关注插入头节点的情况。此时需要拿到尾节点，然后将其next指向新节点。

```
public void add(int index, E element) {
    rangeCheckForAdd(index);
		
    if (index == 0) {
        Node<E> newFirst = new Node<>(element, first);
        // 拿到最后一个节点
        Node<E> last = (size == 0) ? newFirst : node(size - 1);
        last.next = newFirst;
        first = newFirst;
    } else {
        Node<E> prev = node(index - 1);
        prev.next = new Node<>(element, prev.next);
    }
    size++;
}
```

#### 2、删除节点

- 如果删除的是头节点，删除后需让last指向新的头节点。
- 当只有一个节点并删除时, first指向null。

```
public E remove(int index) {
    rangeCheck(index);
		
    Node<E> node = first;
        //删除头节点
        if (index == 0) {
            // 只有一个节点
            if (size == 1) {
                first = null;
            } else {
                Node<E> last = node(size - 1);
                first = first.next;
                last.next = first;
            }
        } else {
            Node<E> prev = node(index - 1);
            node = prev.next;
            prev.next = node.next;
        }
        size--;
        return node.element;
    }
```

### 四、双向循环链表

- 头节点的prev指向尾节点。
- 尾节点的next指向头节点。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668760980846-8ff58d00-f9f2-4c4c-bdcb-ad74d54cd52e.png)

### 五、双向循环链表接口设计

- 相较于双向链表，双向循环链表需要重写插入节点、删除节点两个方法。

### 六、双向循环链表接的实现

#### 1、插入节点

- 需特殊处理添加第一个元素和添加到尾节点两种特殊情况。

```
public void add(int index, E element) {
    rangeCheckForAdd(index);
    // 如果 index == size, 说明添加的索引是最后位置
    if (index == size) {
    	// 创建新节点, prev指向原链表的尾节点, next指向首节点
    	Node<E> node = new Node<>(last, element, first);
    	// 当原链表没有任何节点
    	if (size == 0) {
            first = node;
            last = node;
            node.prev = node;
            node.next = node;
        }else {
            // 原链表尾节点next指向node
            last.next = node;
            // 原链表头结点prev指向node
            first.prev = node;
            // last指向新的尾节点
            last = node;
        }
    }else {
        // 添加新节点后的下一个节点
        Node<E> next = node(index);
        // 添加新节点后的上一个节点
        Node<E> prev = next.prev;
        // 创建新节点, 新节点的上一个节点时prev, 新节点的下一个节点是next
        Node<E> node = new Node<>(prev, element, next);
        // next的上一个节点是新节点
        next.prev = node;
        // prev的下一个节点是新节点
        prev.next = node;
        // 当next == first时, 说明新添加节点的索引是0
        if (next == first) { 
        	first = node;
        }
    }
    size++;
}
```

#### 2、删除节点

- 删除节点，就是在环上去掉某一个节点，然后根据删除的节点是首节点或者尾节点来处理first和last。
- 需要特殊处理只有一个节点的删除操作。

```
public E remove(int index) {
    // 需要删除的节点
    Node<E> node = node(index);	
    if (size == 1) {
        first = null;
        last = null;
    }else {
        // 删除节点的前一个节点
        Node<E> prev = node.prev;
        // 删除节点的后一个节点
        Node<E> next = node.next;
        next.prev = prev;
        prev.next = next;
        // 如果node == first, 说明删除的是第一个节点
        if (node == first) {
            first = next;
        }
        // 如果next == last, 说明删除的是最后一个节点
        if (next == last) {
            last = prev;
        }	
    }
    size--;
    return node.element;
}
```

# 6.栈

### 一、栈

- 栈是一种特殊的线性表, 只能在一端进行操作。
- 往栈中添加元素的操作，一般叫做push，入栈。
- 从栈中移除元素的操作，一般叫做pop，出栈(只能移除栈顶的元素)。
- 栈的内部实现可以使用动态数组或双向链表实现。
- 栈的主要操作是在尾部添加或删除元素。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668762362850-20cb61ff-383a-407d-9900-3c8db5d0ec08.png)

### 二、栈的接口设计

```
public class Stack<E> {
    // 使用动态数组实现栈
    private List<E> list = new ArrayList<>();
    // 元素的数量
    public int size();
    // 是否为空
    public boolean isEmpty();
    // 入栈
    public void push(E element);
    // 出栈
    public E pop();
    // 获取栈顶元素
    public E top();
}
```

### 三、栈的实现

```
public class Stack<E> {
    // 使用 动态数组存储数组
    private ArrayList<E> list;
    public Stack() {
        // 初始化方法中创建列表
    	this.list = new ArrayList<>();
    }
    public int size() {
    	// 栈中元素数量, 就是列表中存储的元素数量
    	return list.size();
    }
    public boolean isEmpty() {
    	// 栈是否空, 就是列表是否空
    	return list.isEmpty();
    }
    public void push(E element) {
    	// 入栈, 将元素添加到列表的最后面
    	list.add(element);
    }
    public E pop() {
    	// 出栈, 将列表中最后一个元素删除并返回
    	return list.remove(list.size() - 1);
    }
    public E top() {
    	// 查看栈顶元素, 就是查看列表中的最后一个元素
    	return list.get(list.size() - 1);
    }
    public void clear() {
    	// 清空栈, 就是清空列表
    	list.clear();
    }
}
```

### 四、leetcode算法题

#### 1、[有效的括号](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fvalid-parentheses%2F)

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668762362875-445ac337-f882-452d-b7e3-1bdde7a66e5d.png)

```
public boolean isValid1(String s) {
    Stack<Character> stack = new Stack<>();
		
    int len = s.length();
    for (int i = 0; i < len; i++) {
        char c = s.charAt(i);
        if (c == '(' || c == '{' || c == '[') { // 左括号
            stack.push(c);
        } else { // 右括号
            if (stack.isEmpty()) return false;
				
            char left = stack.pop();
            if (left == '(' && c != ')') return false;
            if (left == '{' && c != '}') return false;
            if (left == '[' && c != ']') return false;
        }
    }
    return stack.isEmpty();
}
```

#### 2、[括号的分数](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fscore-of-parentheses%2Fcomments%2F)

#### 3、[基本计算器](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fbasic-calculator%2F)

#### 4、[逆波兰表达式求值](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fevaluate-reverse-polish-notation%2F)

# 7.队列

### 一、队列

- 队列是一种特殊的线性表，只能在头尾两端操作。
- 队尾（rear）: 只能从队尾添加元素, 一般叫做enQueue, 入队。
- 对头（front）: 只能从队头移除元素, 一般叫做deQueue, 出队。
- 先进先出的原则，First In First Out，FIFO。
- 队列的内部实现可以使用动态数组或双向链表实现。
- 优先使用双向链表，因为队列主要是往头尾操作元素。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668764529297-f675643a-0fcb-4413-a749-9844c9b12156.webp)

### 二、队列的接口设计

```
public class Queue<E> {
    // 使用双向链表实现队列
    private List<E> list = new LinkedList<>();
    // 元素的数量
    public int size();
    // 是否为空
    public boolean isEmpty();
    // 入队
    public void enQueue(E element);
    // 出队
    public E deQueue();
    // 获取队列的头元素
    public E front();
}
```

### 三、队列的实现

```
public class Queue<E> {
    private List<E> list = new LinkedList<>();
	
    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public void enQueue(E element) {
        list.add(element);
    }

    public E deQueue() {
        return list.remove(0);
    }

    public E front() {
        return list.get(0);
    }
}
```

链表的末尾是队头，头部是队尾

### 四、leetcode算法题

[用栈实现队列](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fimplement-queue-using-stacks%2F)![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668764529283-57e25933-ae70-491c-b1b4-bee501e14153.webp)

```
public class _232_用栈实现队列 {    
    private Stack<Integer> inStack;
    private Stack<Integer> outStack;

    /** Initialize your data structure here. */
    public _232_用栈实现队列() {
        inStack = new Stack<>();
        outStack = new Stack<>();
    }
    
    /** 入队 */
    public void push(int x) {
        inStack.push(x);
    }
    
    /** 出队 */
    public int pop() {
    	checkOutStack();
    	return outStack.pop();
    }
    
    /** 获取队头元素 */
    public int peek() {
    	checkOutStack();
    	return outStack.peek();
    }
    
    /** 是否为空 */
    public boolean empty() {
    	return inStack.isEmpty() && outStack.isEmpty();
    }
    
    private void checkOutStack() {
    	if (outStack.isEmpty()) {
        	while (!inStack.isEmpty()) {
        		outStack.push(inStack.pop());
        	}
        }
    }
}
```

### 五、双端队列（Deque）

- 双端队列是能在头尾两端添加、删除的队列。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668764529323-bb4aa09c-df5a-48bc-94fd-5b8754cc85cb.webp)

### 六、双端队列的接口设计&实现

```
public class Deque<E> {
    private List<E> list = new LinkedList<>();
	
    // 元素的数量
    public int size() {
        return list.size();
    }
    // 是否为空
    public boolean isEmpty() {
        return list.isEmpty();
    }
    // 从队头出队
    public E deQueueFront() {
        return list.remove(0);
    }
    // 从队头入队
    public void enQueueFront(E element) {
        list.add(0, element);
    }
    // 从队尾入队
    public void enQueueRear(E element) {
        list.add(element);
    }
    // 从队尾出队
    public E deQueueRear() {
        return list.remove(list.size() - 1);
    }
    // 获取队列的头元素
    public E front() {
        return list.get(0);
    }
    // 获取队列的尾元素
    public E rear() {
        return list.get(list.size() - 1);
    }
}
```

### 七、循环队列（Circle Queue）

- 请阅读[小码哥《恋上数据结构与算法》笔记（一）：动态数组](https://juejin.im/editor/posts/5df740526fb9a0164423d976)，第五条：ArrayList能否进一步优化。
- 队列内部实现也可以用动态数组实现，并且将各项接口优化到O(1)的时间复杂度， 这个用数组实现并优化之后的队列就叫做: 循环队列。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668764529290-8255f728-da49-412d-8423-b05b4c09c103.webp)
- 使用一个索引变量front控制第0个元素（队头）所在位置。
- 每一次出队，就将front位置的元素取出并删除，然后front向后+1。
- 每一次入队，都根据front和当前元素数量计算出入栈元素应该存入的索引，然后将元素存入到数组对应索引的位置上。

### 八、循环队列的接口设计

```
public class CircleQueue<E> {
    // 记录第0个元素的索引
    private int front;
    // 当前队列存储的元素个数
    private int size;
    // 用来存储元素的数组
    private E[] elements;
    // 当前队列存储的元素数量
    public int size();
    // 当前队列是否为空
    public boolean isEmpty();
    // 入队
    public void enQueue(E element);
    // 出队
    public E deQueue();
    // 查看索引为0的元素
    public E front();
}
```

### 九、循环队列的实现

#### 1、构造方法

- 如果构建的数组空间小于默认空间，则会以默认空间构建数组。

```
public class ArrayList<E> {
    private E[] elements;
    // 设置elements数组默认的初始化空间
    private static final int DEFAULT_CAPACITY = 10;
	
    public CircleQueue() {
        elements = (E[]) new Object[DEFAULT_CAPACITY];
    }
}
```

#### 2、入队

- 入队前需要考虑两个问题：队列是否需要扩容和计算入队实际索引。

##### 2.1、数组扩容

- 扩容相关内容请阅读[小码哥《恋上数据结构与算法》笔记（一）：动态数组](https://juejin.im/editor/posts/5df740526fb9a0164423d976)，2.2节内容。
- 扩容后front需重置位0。

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668764529316-779b03c5-39a8-4a43-92d5-c0e4433e3c26.webp)

```
private void ensureCapacity(int capacity) {
    int oldCapacity = elements.length;
    if (oldCapacity >= capacity) return;
		
    // 新容量为旧容量的1.5倍
    int newCapacity = oldCapacity + (oldCapacity >> 1); //位运算
    E[] newElements = (E[]) new Object[newCapacity];
    for (int i = 0; i < size; i++) {
        newElements[i] = elements[index(i)];
    }
    elements = newElements;
		
    // 重置front
    front = 0;
}
```

##### 2.2、索引计算

- 预期入队索引 = 第0个元素索引 + 当前队列元素个数。
- 如果预期入队索引大于等于数组长度，实际入队索引 = 预期入队索引 - 数组长度。
- 如果预期入队索引小于数组长度，实际入队索引 = 预期入队索引。

```
private int index(int index) {
    index += front;
    return index - (index >= elements.length ? elements.length : 0);
}
```

- 那么入队的代码如下：

```
public void enQueue(E element) {
    // 数组扩容判断
    ensureCapacity(size + 1);
    // 索引计算，并赋值
    elements[index(size)] = element;
    // size加一
    size++;
}
```

#### 3、出队

- 出队后需要更新front。

```
public E deQueue() {
    // 获取出队元素
    E frontElement = elements[front];
    // 将索引位置致空
    elements[front] = null;
    // 更新font
    front = index(1);
    // size减一
    size--;
    // 返回出队元素
    return frontElement;
}
```

### 十、循环双端队列

- 略

# 8.二叉树（Binary Tree）

### 一、树（Tree）的基本概念

#### 1、节点

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668770979373-4f893d5d-7a38-4ff8-aebd-564cfe8b47ad.webp)

- **节点**：1、2、3、4、5、6、21、22、31、51、52、61、221、222、223
- **根节点**：1，一棵树只有一个根节点
- **父节点**：1是2、3、4、5、6的父节点，2是21、22的父节点，以此类推。
- **子节点**：与父节点相反，2、3、4、5、6是1的子节点，21、22是2的子节点，以此类推。
- **兄弟节点**：同一个父节点下的子节点互为兄弟节点，例如上图中的21和22是兄弟节点，但是22和31虽然都在同一层，而父节点不同，所以不是兄弟节点。
- **空树**：一棵树没有任何节点，包括没有根节点。
- 一棵树可以只有一个节点，也就是根节点。

#### 2、子树

- **子树**：一棵树可以有很多节点，而其中除了整体是一颗树外，其中的子节点也可以单独看成一棵树，例如2、21、22、221、222、223就是一颗子树。
- **左子树**：左侧的子节点称为左子树，例如21是2的左子树。
- **右子树**：右侧的子节点称为右子树，例如22是2的右子树。

#### 2、度

- **节点的度**：子树的个数，即子节点的个数，就是节点的度，例如根节点1有5个子节点，所以根节点1的度是5。
- **树的度**：所有节点度中的最大值，上图中节点度最大的是根节点， 所以这棵树的度是5。以最大的节点的度代表树的度。
- **叶子节点**：度为0的节点，即没有子节点的节点。
- **非叶子节点**：度不为0的节点，即有子节点的节点。

#### 3、深度&高度

- **层数**：根节点第一层，根节点的子节点在第2层，以此类推(有些教程是从第0层开始计算)。
- **节点的深度**：从根节点到当前节点的唯一路径上的节点总数。

- 节点2的深度：1->2，经历2个节点，所以深度为2。
- 节点223的深度：1->2->22->223，经历4个节点，所以深度是4。

- **节点的高度**：从当前节点到最远叶子节点的路径上的节点总数。

- 节点2的高度：2->22->221，经历3个节点，所以深度是3
- 节点223的深度: 223，只有一个节点，所以深度是1。

- **树的深度**：所有节点深度的最大值。

- 1->2->22->221，所以树的深度是4。

- **树的高度**：所有节点高度的最大值。

- 1->2->22->221，所以树的高度是4。

- 树的高度等于树的深度

#### 4、树的分类

- **有序树**：树中任意节点的子节点之间有顺序关系，即两个树所有的值都一样，但是其中的子节点顺序不一样，就是两颗不同的有序树。
- **无序树**：树中任意节点的子节点之间没有顺序关系，也称为自由树。
- **森林**：由m（m >= 0）颗互不相交的树组成的集合。

### 二、二叉树

#### 1、二叉树的性质

- 每个节点的度最大为2，即最多拥有2颗子树。
- 左子树和右子树是有顺序的，比如所有节点左子树小于右子树。
- 即使某节点只有一颗子树，也要区分左右子树。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668770979351-64211164-a499-41c4-97d5-aeb01b3f1baf.webp)
- 非空二叉树的第 i 层，最多有`2i-1`个节点 (i >= 1)。
- 高度为 h 的二叉树最多有`2h- 1`个节点 (h >= 1)。
- 对于任意一颗非空二叉树，如果叶子节点个数为 n0，度为2的节点个数为 n2，则有：`n0 = n2 + 1`。

- 假设度为1 的节点个数为n1，那么二叉树的总结点n = n0 + n1 + n2 二叉树的边数T = n1 + 2 * n2，这是因为n1的每个节点下有1个子节点，所以边是n1，n2的每一个节点都有2个子节点所以是n2 * 2。反过来看，因为所有的节点上面都有一条边，只有根节点上没有边。所以，二叉树的边数T = n1 + 2 * n2 = n - 1 = n0 + n1 + n2 - 1。即: n1 + 2 * n2 = n0 + n1 + n2 - 1 可以推出 n0 = n2 + 1。

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668770979352-843569f5-1168-473e-8282-1fec6056bed6.webp)

#### 2、二叉树的种类

##### a、真二叉树

- 所有节点的度要么为0，要么为2，即没有只有一个子节点的节点。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668770979388-66078dd6-1c44-4f71-a561-d76544e1cedd.webp)

##### b、满二叉树

- 所有节点的度要么为0，要么为2。且所有的叶子节点都在最后一层。
- 在同样高度的二叉树中，满二叉树的叶子节点数量最多，总结点数量最多。
- 满二叉树一定是真二叉树，真二叉树不一定是满二叉树。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668770979359-2dfb9c8e-fe5f-44a0-aa60-66fa6057c9ec.webp)
- 假设满二叉树的高度为h(h >= 1)，那么：
- 第i层的节点数量：`2i-1`
- 叶子节点数量：`2h-1`
- 总结点数量 n：

- n = 2^h - 1 = 2^0 + 2^1 + 2^2 + 2^3 +...+ h^(h - 1)
- h = log2(n + 1)

##### c、完全二叉树

- 叶子节点只会出现最后2层，最后1层的叶子节点都靠左对齐。（从上往下、从左往右排列，不一定排满）
- 完全二叉树从根节点至倒数第2层是一颗满二叉树。
- 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668770980980-dd85e4a7-90ec-455c-87df-b9a66d23d337.webp)
- 度为1的节点只有左子树。
- 度为1的节点要么是1个，要么是0个。
- 同样节点数量的二叉树，完全二叉树的高度最小。
- 假设完全二叉树的高度为 h(h >= 1)，那么：

- 至少有`2h-1`个节点(2^0 + 2^1 + 2^2 + ... + 2^(h - 2) + 1)。
- 最多有`2h-1`个节点(2^0 + 2^1 + 2^2 + ... + 2^(h - 1), 满二叉树)。
- 总节点数量为 n：

- 2^(h - 1) <= n < 2^h
- h - 1 <= log2(n) < h
- h = floor(log2n) + 1

- 一个有n个节点的完整二叉树(n > 0)，从上到下，从左到右对节点从1开始编号，对任意第i个节点：

- 如果i = 1，它是根节点。
- 如果i > 1，它的父节点编号为floor(i/2)。
- 如果2i <= n，它的左子节点编号为2i。
- 如果2i > n，它无左子点。
- 如果2i + 1 <= n，他的右子节点编号为2i + 1。
- 如果2i + 1 > n，它无右子节点。

- 一个有n个节点的完整二叉树(n > 0), 从上到下，从左到右对节点从0开始编号, 对任意第i个节点：

- 如果i = 0，它是根节点。
- 如果i > 0，它的父节点编号为floor((i- 1)/2)。
- 如果2i + 1 <= n - 1，它的左子节点编号为2i + 1。
- 如果2i + 1 > n - 1，它无左子点。
- 如果2i + 2 <= n - 1，他的右子节点编号为2i + 2。
- 如果2i + 2 > n - 1，它无右子节点。

### 三、leetcode算法题

#### 1、[寻找完全二叉树的叶子节点](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Ffind-leaves-of-binary-tree%2F)

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668770981048-b0a26744-a7a5-41c6-bc7f-1d68585f376b.webp)

- 总节点数量为n。
- n如果是偶数，叶子节点数量n0 = n / 2。
- n如果是奇数，叶子节点数量n0 = (n + 1) / 2。
- 可以一并写成：n0 = floor((n + 1) / 2)。
- floor为向下取整。
- 在代码中表示为 n0 = （n+1）>> 1

# 9.二叉搜索树

## 9.1 二叉搜索树（Binary Search Tree）

- 又叫二叉查找树、二叉排序树，简称 **BST**
- 任意一个节点的值都大于其左子树所有节点的值。
- 任意一个节点的值都小于其右子树所有节点的值。
- 它的左右子树也是一颗二叉搜索树。
- 二叉搜索树存储的元素必须具备可比较性。

- 比如 int，double 等。
- 如果是自定义类型，需要指定比较方式。
- 不允许为 null（因为 null 无法比较）。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1669692858259-ac740be3-4bdb-4c72-b139-4bde417dc5d5.png)

## 9.2 二叉搜索树接口设计

```
public class BinarySearchTree<E>{
    private int size; // 元素的个数
    private Node<E> root; // 根节点
    private Comparator<E> comparator; // 比较器

    // 元素的数量
    public int size() 
    // 是否为空
    public boolean isEmpty() 
    // 清空所有元素
    public void clear() 
    // 添加元素
    public void add(E element) 
    // 删除元素
    public void remove(E element) 
    // 是否包含某元素
    public boolean contains(E element) 
}
```

## 9.3 二叉搜索树的实现

### （1）构造函数

- 二叉树添加的数据必须是可以比较的，需要定义比较规则，负责比较两个节点的大小。

- 实现 Comparable 接口，重写 comparTo方法，方法中定义比较规则
- 自定义 Comparator 比较器（匿名内部类），重写 compare 方法，方法中定义比较规则

- BinarySearchTree 中我们对两种比较规则都进行实现，已实现灵活的调用、比较
- BinarySearchTree中维护 comparator 用于接收外部传入的比较器
- 在我们自己实现的比较方法 compare 中，如果外部传入了比较器，使用比较器比较，如果没有传入，则将元素强制转换成 Comparable 类型（二叉树的元素必须是可比较的），调用 compareTo 方法进行比较

```
public class BinarySearchTree<E> {
    // 不使用外部传入的比较器（默认实现了Comparable接口进行比较） 
    public BinarySearchTree() {
        this(null);
    }
    // 构造函数传入比价器进行比较
    public BinarySearchTree(Comparator<E> comparator) {
        this.comparator = comparator; 
    }
    
    /**
    * @return 返回值等于0，代表e1和e2相等；返回值大于0，代表e1大于e2；返回值小于于0，代表e1小于e2
    */
    private int compare(E e1, E e2) {
        if (comparator != null) {
            return comparator.compare(e1, e2);
        }
        return ((Comparable<E>)e1).compareTo(e2);
    }
}
```

### （2）节点

- 二叉树的元素是存放在节点中的，所以需要创建私有节点类。
- 节点还需记录自己的左节点，右节点，父节点。

```
private static class Node<E> {
    // 存放元素
    E element;
    // 左节点
    Node<E> left;
    // 右节点
    Node<E> right;
    // 父节点
    Node<E> parent;
    // 构造函数
    public Node(E element, Node<E> parent) {
        this.element = element;
        this.parent = parent;
    }
}
```

### （3）添加元素

- 首先找到父节点 parent，然后创建新节点 node，最后比较 parent 和 node 的大小。
- 如果 node 小于 parent，将 parent.left 赋值给 parent。
- 如果 node 大于 parent，将 parent.right 赋值给 parent。
- 循环比较操作，直到 parent.left 或 parent.right 为空，将 node 赋值给 parent.left 或 parent.right 即可。
- 添加元素前，首先需要检查节点的值是否为空。

```
private void elementNotNullCheck(E element) {
    if (element == null) {
    throw new IllegalArgumentException("element must not be null");
    }
}
```

- 另外，还需要特殊处理添加元素到首节点。

```
public void add(E element) {
    // 判断节点的值是否为空。
    elementNotNullCheck(element);
		
    // 添加第一个节点
    if (root == null) {
        root = new Node<>(element, null);
        size++;
        return;
    }
    // 添加的不是第一个节点
    Node<E> parent = root;
    Node<E> node = root;
    // 比较结果
    int cmp = 0;
    while (node != null) {
        // 在之前定义的比较函数
        cmp = compare(element, node.element);
        //保存node的父节点
        parent = node; 
        if (cmp > 0) { 
            // 右子节点
            node = node.right;
        } else if (cmp < 0) { 
            //左子节点
            node = node.left;
        } else { 
            // 相等
            node.element = element;
            return;
        }
    }

    // 看看插入到父节点的哪个位置
    Node<E> newNode = new Node<>(element, parent);
    if (cmp > 0) {
        parent.right = newNode;
    } else {
        parent.left = newNode;
    }
    size++;
}
```

### （4）删除元素

- tips：删除元素会使用前驱，后继的知识，可以先阅读:

- 五、二叉搜索树（Binary Search Tree）的前驱和后继

- 删除节点分为删除叶子节点，删除度为1的节点，删除度为2的节点。
- 删除叶子节点，直接删除即可。

- 如果node == node.parent.left

- node.parent.left = null

- 如果node == node.parent.right

- node.parent.right = null

- 如果node.parent == null

- root = null

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668771037817-e04001b0-733e-4371-b6c4-33ecbb4b0d01.webp)

- 删除度为1的节点，用子节点替代原节点的位置。child = node.left或者child = node.right

- 用child替代node的位置。
- 如果node是左子节点：

- child.parent = node.parent
- node.parent.left = child

- 如果node是右子节点：

- child.parent = node.parent
- node.parent.right = child

- 如果node是根节点：

- root = child

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668771037806-56647064-46a4-4d41-b155-fb6d05c1be64.webp)

- 删除度为2的节点，先用前驱或后继节点的值覆盖原节点的值，然后删除相应的前驱或者后继节点。（如果这个节点的度为2，那么它的前驱，后继节点的度只能是1和0）

```
private void remove(Node<E> node) {
    if (node == null) return;
		
    size--;
		
    if (node.hasTwoChildren()) { // 度为2的节点
        // 找到后继节点
        Node<E> s = successor(node);
        // 用后继节点的值覆盖度为2的节点的值
        node.element = s.element;
        // 删除后继节点
        node = s;
    }
		
    // 删除node节点（node的度必然是1或者0）
    Node<E> replacement = node.left != null ? node.left : node.right;
		
    if (replacement != null) { // node是度为1的节点
        // 更改parent
        replacement.parent = node.parent;
        // 更改parent的left、right的指向
        if (node.parent == null) { // node是度为1的节点并且是根节点
            root = replacement;
        } else if (node == node.parent.left) {
            node.parent.left = replacement;
        } else { // node == node.parent.right
            node.parent.right = replacement;
        }
    } else if (node.parent == null) { // node是叶子节点并且是根节点
        root = null;
    } else { // node是叶子节点，但不是根节点
        if (node == node.parent.left) {
            node.parent.left = null;
        } else { // node == node.parent.right
            node.parent.right = null;
        }
    }
}
```

### （5）打印元素

可以使用这个工具类二叉树直观的打印出来，用来判断二叉树是否正确，元素是否正确插入

[https://github.com/CoderMJLee/BinaryTrees](https://github.com/CoderMJLee/BinaryTrees)

## 9.4 二叉搜索树的遍历

- 根据节点访问顺序的不同，二叉树的常见遍历方法有4种。
- 所谓前中后序遍历，指的是根节点遍历顺序。

### （1）前序遍历

- 访问顺序： 根节点 -> 遍历左子树 -> 遍历右子树
- 访问完根节点之后，因为左右子树同样是二叉树，所以按照同样规则进行遍历

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1669706144978-6076e4f1-1062-49f2-b4c4-0e8a6908ade9.png)

```
// 递归实现前序遍历
public void preorderTraversal(Node<E> node) {
    // 退出条件
    if (node == null) return;
    // 打印节点值	
    System.out.println(node.element);
    // 前序遍历左子树
    reorderTraversal(node.left);
    // 前序遍历右子树
    preorderTraversal(node.right);
}
// 非递归，使用stack实现前序遍历
public void preOlderTraversal(Node<E> node){
    // 判断节点是否为空
   if (node == null) return;
    Stack<Node<E>> stack = new Stack<>();
    // 先将根节点压入栈
    stack.push(node);
    while(!stack.isEmpty()){
        // 取出栈顶元素并打印
        Node<E> eNode = stack.pop();
        System.out.println(eNode.element);
        // 先压入右子节点
        if (eNode.right != null)
            stack.push(eNode.right);
        // 再压入左子节点
        if (eNode.left != null)
            stack.push(eNode.left);
    }
}
```

### （2）中序遍历

- **当需要按升序或降序获取节点时，使用中序遍历。**
- 访问顺序：遍历左子树 -> 根节点 -> 遍历右子树
- 遍历结果：1、3、4、6、7、8、10、13、14
- 如果是一颗二叉搜索树，遍历的结果按从小到大排序。
- 另一种访问顺序：遍右左子树 -> 根节点 -> 遍历左子树
- 遍历结果：14、13、10、8、7、6、4、3、1
- **二叉搜索树的中序遍历结果是升序或降序的。**
- 访问8，就需要先访问3，同样需要先访问1，访问完1之后，再访问3，之后需要访问6，访问6之前需要先访问4，访问完7之后，访问10，访问10之前需要访问10的左子节点，但不存在，访问10之后访问14，访问14之前需要先访问13

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1669710427567-b81bae36-693c-4a33-a39f-a7cb47bdc0ca.png)

```
// 递归实现中序遍历
public void inorderTraversal(Node<E> node) {
    // 退出条件
    if (node == null) return;
    // 中序遍历左子树	
    inorderTraversal(node.left);
    // 打印节点值
    System.out.println(node.element);
    // 中序遍历右子树
    inorderTraversal(node.right);
}
// 非递归，使用Stack实现中序遍历
public void inOlderTraversal(Node<E> node){
    // 退出条件
    if (node == null) return;
    Stack<Node<E>> stack = new Stack<>();
    while(node != null || !stack.isEmpty()){
        // 一直找到最左节点，并将路径元素压入栈
        if (node != null){
            stack.push(node);
            node = node.left;
        // 根据弹出的元素找到右子节点
        }else{
            node = stack.pop();
            System.out.println(node.element);
            node = node.right;
        }
    }
}
```

### （3）后序遍历

- 当需要先子后父操作时，可以使用后序遍历。
- 访问顺序：遍历左子树 -> 遍历右子树 -> 根节点

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1669741222190-acfce4d6-5bdb-4521-8da8-76986af3c67c.png)

```
// 递归实现后序遍历
private void postorderTraversal(Node<E> node) {
    // 退出条件
    if (node == null) return;
    // 后序遍历左子树
    postorderTraversal(node.left);
    // 后序遍历右子树
    postorderTraversal(node.right);
    // 打印节点值
    System.out.println(node.element);
}
// 非递归，使用两个Stack实现后序遍历
public void postOlderTraversal1(Node<E> node){
    if (node == null) return;
    Stack<Node<E>> stack1 = new Stack<>();
    Stack<Node<E>> stack2 = new Stack<>();
    // 先将指定元素压入栈1
    stack1.push(node);
    // 如果栈1不为空
    while(!stack1.isEmpty()){
        // 弹出栈顶元素，压入栈2
        Node<E> cur = stack1.pop();
        stack2.push(cur);
        // 并将弹出元素的左子节点和右子节点压入栈1
        if (cur.right!= null)
            stack1.push(cur.left);
        if (cur.left!= null)
            stack1.push(cur.right);
    }
    // 如果栈2不为空
    while(!stack2.isEmpty()){
        // 弹出栈顶元素，打印信息
        Node<E> cur = stack2.pop();
        System.out.println(cur.element);
    }
}
```

### （4）层序遍历

- 需要计算二叉树高度或判断是否为完全二叉树时，可使用层序遍历。
- 访问顺序：从上到下，从左到右依次访问节点。
- 遍历思路：

1. 使用队列存储节点。
2. 将根节点入队列。
3. 将队列头节点A出队列，进行访问。
4. 将节点A的左子节点入队列。
5. 将节点A的右子节点入队列。
6. 循环执行2-4步骤。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1669741327196-35b0065c-bd39-4ca3-9253-569c7e15177f.png)

```
public void levelOrderTranversal() {
    // 如果根节点为空，直接返回
    if (root == null) return;
    // 创建存储节点的队列
    Queue<Node<E>> queue = new LinkedList<>();
    //将头节点入队列
    queue.offer(root);
    //退出条件，当队列为空
    while (!queue.isEmpty()) {
        //取出队列头元素
        Node<E> node = queue.poll();
        //打印头元素
        System.out.println(node.element);
        //如果头元素左子树不为空
        if (node.left != null) {
            //将头元素左子树入队
            queue.offer(node.left);
        }
        //如果头元素右子树不为空
        if (node.right != null) {
            //将头元素右子树入队
            queue.offer(node.right);
        }
    }
}
```

## 9.5 二叉搜索的前驱和后继

### （1）前驱节点（predecessor）

- **中序遍历时的前一个节点。**
- 如果是二叉搜索树，前驱节点就是前一个比它小的节点。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668771039036-10b46bb8-f91f-48aa-bf32-a30882137f65.webp)
- 寻找前驱节点分三种情况：

1. 左子树不为空

- 举例：6，13，8
- predecessor = node.left.right.right.right...
- 终结条件：right = null

2. 左子树为空，父节点不为空

- 举例：7，11，9，1
- predecessor = node.parent.parent.parent...
- 终结条件：node在parent的右子树中。

3. 左子树为空且父节点为空

- 那就没有前驱节点
- 举例：没有左子树的根节点。

```
protected Node<E> predecessor(Node<E> node) {
    if (node == null) return null;
    // 前驱节点在左子树当中（left.right.right.right....）
    Node<E> p = node.left;
    if (p != null) {
        while (p.right != null) {
            p = p.right;
        }
        return p;
    }
    // 从父节点、祖父节点中寻找前驱节点
    while (node.parent != null && node == node.parent.left) {
        node = node.parent;
    }
    // node.parent == null
    // node == node.parent.right
    return node.parent;
}
```

### （2）后继节点（successor）

- 中序遍历时的后一个节点。
- 如果是二叉搜索树，后继节点就是前一个比它大的节点。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668771039099-5b956843-6981-4157-9735-727b13dac67c.webp)
- 寻找后继节点分三种情况：

1. 右子树不为空

- 举例：1，4，4
- successor = node.right.left.left.left...
- 终结条件：left = null

2. 右子树为空，父节点不为空

- 举例：7，6，3，11
- successor = node.parent.parent.parent...
- 终结条件：node在parent的左子树中。

3. 右子树为空且父节点为空

- 那就没有前驱节点
- 举例：没有右子树的根节点。

```
protected Node<E> successor(Node<E> node) {
    if (node == null) return null;
    // 前驱节点在左子树当中（right.left.left.left....）
    Node<E> p = node.right;
    if (p != null) {
        while (p.left != null) {
            p = p.left;
        }
        return p;
    }
    // 从父节点、祖父节点中寻找前驱节点
    while (node.parent != null && node == node.parent.right) {
        node = node.parent;
    }
    return node.parent;
}
```

## 9.6 leetcode算法题

### （1）[二叉树的最大深度](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fmaximum-depth-of-binary-tree%2Fcomments%2F)

- 树的高度 = 子节点高度 + 1
- 子节点高度 = Max(左子树，右子树)

```
// 递归实现
private int height(Node<E> node) {
    if (node == null) return 0;
    return 1 + Math.max(height(node.left), height(node.right));
}
```

- 也可以通过层序遍历求得最大深度：

```
public int height() {
    if (root == null) return 0;
    // 树的高度
    int height = 0;
    // 存储着每一层的元素数量
    int levelSize = 1;
    Queue<Node<E>> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        Node<E> node = queue.poll();
        levelSize--;
        if (node.left != null) {
            queue.offer(node.left);
        }
        if (node.right != null) {
            queue.offer(node.right);
        }
        // 意味着即将要访问下一层。
        if (levelSize == 0) { 
            // 此时队列的元素个数即为下一层元素总数。
            levelSize = queue.size();
            //即将访问下一层，树的高度+1
            height++;
        }
    }
    return height;
}
```

### （2）[二叉树的完全性检验](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fcheck-completeness-of-a-binary-tree%2F)

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668771039082-c3cbd830-03eb-43c0-af22-3230e8ab9cfa.webp)

```
public boolean isComplete() {
    if (root == null) return false;
		
    Queue<Node<E>> queue = new LinkedList<>();
    queue.offer(root);
		
    boolean leaf = false;
    while (!queue.isEmpty()) {
        Node<E> node = queue.poll();
        if (leaf && !node.isLeaf()) return false;
        if (left != null && right != null) {
	        queue.offer(node.left);
	        queue.offer(node.right);
	    } else if (node.left == null && node.right != null) {
	        return false;
        } else { // 后面遍历的节点都必须是叶子节点
            leaf = true;
            if (node.left != nill){
                queue.offer(node.left)
            }
        }
    }
    return true;
}
```

### （3）[翻转二叉树](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Finvert-binary-tree%2F)

- 只要能够遍历二叉树，就可以完成二叉树的翻转。

![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668771040075-bf2dcb66-9bda-4a4d-a602-fcf2aa4ef05b.webp)

```
//前序遍历
public TreeNode invertTree(TreeNode root) {
    if (root == null) return root;
    //翻转
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;
	   
    invertTree(root.left);
    invertTree(root.right);
    return root;
}
	
//后序遍历
public TreeNode invertTree(TreeNode root) {
    if (root == null) return root;
	   
    invertTree(root.left);
    invertTree(root.right);
    //翻转
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;
      
    return root;
}
	
//中序遍历
public TreeNode invertTree(TreeNode root) {
    if (root == null) return root;
	   
    invertTree(root.left);
    //翻转
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;
    // 这里放入的left其实是之前的right
    invertTree(root.left);
      
    return root;
}

//层序遍历
public TreeNode invertTree(TreeNode root) {
    if (root == null) return root;
		
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
		
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        //翻转
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;
			
        if (node.left != null) {
            queue.offer(node.left);
        }
			
        if (node.right != null) {
            queue.offer(node.right);
        }
    }
    return root;
}
```

### （4）根据遍历结果重构二叉树

[从中序与后序遍历序列构造二叉树](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fconstruct-binary-tree-from-inorder-and-postorder-traversal%2F)

[从前序与中序遍历序列构造二叉树](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fconstruct-binary-tree-from-preorder-and-inorder-traversal%2F)

[根据前序和后序遍历构造二叉树](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fconstruct-binary-tree-from-preorder-and-postorder-traversal%2F)

- 以下结果可以保证重构出唯一的一颗二叉树：

- 前序遍历 + 中序遍历
- 后序遍历 + 中序遍历

- 如果是前序遍历 + 后序遍历：

- 如果它是一颗真二叉树，结果是唯一的。
- 否则结果不唯一。

### （5）[删除二叉搜索树中的节点](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fdelete-node-in-a-bst%2F)

### （6）[二叉搜索树中的搜索](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsearch-in-a-binary-search-tree%2F)

### （7）[二叉搜索树中的插入操作](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Finsert-into-a-binary-search-tree%2F)

### （8）[验证二叉搜索树](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fvalidate-binary-search-tree%2Fcomments%2F)

### （9）[二叉搜索树的最小绝对差](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fminimum-absolute-difference-in-bst%2Fcomments%2F)

### （10）[二叉搜索树结点最小距离](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fminimum-distance-between-bst-nodes%2Fcomments%2F)

### （11）[将有序数组转换为二叉搜索树](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fconvert-sorted-array-to-binary-search-tree%2F)

### （12）[二叉搜索树的范围和](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Frange-sum-of-bst%2F)

### （13）[二叉搜索树的最近公共祖先](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Flowest-common-ancestor-of-a-binary-search-tree%2F)

### （14）[二叉搜索树中第K小的元素](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fkth-smallest-element-in-a-bst%2F)

### （15）[二叉搜索树迭代器](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fbinary-search-tree-iterator%2F)

### （16）[恢复二叉搜索树](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Frecover-binary-search-tree%2F)

## 9.7 二叉搜索树的复杂度

- 如果是按照7，4，9，2，5，8，11的顺序添加节点。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668771040142-b8060277-4245-4454-9855-723b36763788.webp)

- 搜索元素复杂度：O(h) == O(logn)

- 如果是从小到大添加节点。 ![](https://cdn.nlark.com/yuque/0/2022/webp/29046015/1668771040133-a3c710dd-528a-4ed0-97e6-5cec8afd2fb0.webp)

- 搜索元素复杂度：O(h) == O(n)

- 总结：

- 当n比较大时，两者的性能差异比较大。
- 比如n = 1000000时，二叉搜索树的最低高度是20，即最多搜索20次，而退化成链表的二叉搜索树，最多搜索1000000次。

  

# 10.平衡二叉搜索树（AVL）

### 一、平衡二叉搜索树（Balance Binary Search Tree）

#### 1、退化成链表的二叉搜索树

- 删除节点时，可能会导致二叉搜索树退化成链表。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771420059-2b43af4c-ad94-42ad-a819-f6ebbb63744d.png)
- 如果删除2，9，8，11四个节点，就会导致退化。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771420050-a32b1597-bd6a-4295-9f3f-7679552edc9c.png)
- 如何防止二叉搜素树退化成链表？让添加，删除，搜索的复杂度维持在O(logn)。

  

#### 2、平衡（Balance）

- 当节点数量固定时，左右子树的高度越接近，这颗二叉树就越平衡（高度越低）。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771420281-e92c687f-c0f7-43ec-bcd6-90f891526cf1.png)
- 最理想的平衡，就是像完全二叉树，满二叉树那样，高度是最小的。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771420088-babccd5e-a348-4d9b-a479-094bd9c4098d.png)

#### 2、如何改进二叉搜索树？

- 节点的添加，删除顺序是无法限制的，也就是随机的。
- 那么改进方案是：在节点的添加，删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度）。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771420107-ec611a86-637e-454e-95f3-785a9d13b922.png)
- 如果接着继续调整节点的位置，完全可以达到理想平衡，但是付出的代价可能会比较大。如果调整次数太多，反而增加了时间复杂度。
- 所以比较合适的方案是：用尽量少的调整次数达到适度平衡。
- 一颗达到适度平衡的二叉搜索树，可以称之为：平衡二叉搜索树。

#### 3、常见的平衡二叉搜索树

- AVL树：Windows NT内核中广泛使用。
- 红黑树：java的TreeMap，TreeSet，HashMap，HashSet。

### 二、AVL树

- 什么是平衡因子：某节点的左右子树的高度差。
- AVL树的特点：

- 每个节点的平衡因子只可能是1，0，-1。即绝对值<=1，如果超过1，称之为失衡。
- 每个节点的左右子树高度差不超过1。
- 搜索，添加，删除的时间复杂度是O(logn)。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771421319-956090f8-0f2b-48b7-81e5-84f75aa1b02c.png)

- AVL树和红黑树，都是在二叉搜索树的基础上，增加了自平衡的功能。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771421693-bfff679d-7da7-48e9-add1-e889ba303354.png)

### 三、失衡的几种情况

#### 1、添加导致的失衡

- 示例：添加13导致失衡 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771421854-5b568dc2-d201-4871-9d25-54e8a25b6eb8.png)
- 最坏的情况，可能会导致所有祖先节点14，15，9都失衡。
- 但是父节点12，非祖先节点4，6，8，都不可能失衡。

#### 2、添加失衡 LL - 右旋传（单旋）

- n代表node，p代表parent，g代表grandparent![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771421944-a939fb5d-ab12-4f48-a77e-63ea486f0d18.png)
- 如果在T0节点位置增加节点，那么g失去平衡。
- LL表示失衡节点与添加节点的关系，添加节点在失衡节点的左边的左边。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771422331-d872cc09-4033-42bd-8bf6-86de3ae7f359.png)
- 因为是g左边的左边的节点使它失去平衡，所以这种情况称之为LL。
- LL的情况，一般需要右旋转。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771423533-90abd7e9-6ac4-424b-9bc6-6cd014f285f1.png)
- 思路：

- g.left = p.right
- p.right = g
- 让p成为这颗子树的根节点。
- 改变之后整棵树仍然是一颗二叉搜索树：T0 < n < T1 < p < T2 < g < T3。
- 整棵树都达到平衡。

- 还需要注意维护：

- T2，p，g的parent属性。
- 先后更新g，p的高度属性。

#### 3、添加失衡 RR - 左旋转（单旋）

- 如果往T2或T3位置加入一个节点，则g会失衡。
- RR表示失衡节点与添加节点的关系，添加节点在失衡节点的右边的右边。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771423728-19722df2-c2ca-4e45-9547-fb7697f9e383.png)
- 那么我们需要左旋转，使树达到平衡。
- 思路：

- g.right = p.left
- p.left = g
- 让p成为这颗子树的根节点。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771423757-d9b68cbd-0c96-4670-9d96-4f6413e4b587.png)

- 整棵树都达到了平衡。
- 还需要注意维护：

- T1，p，g的parent属性。
- 先后更新g，p的高度属性。

#### 4、添加失衡 LR - RR左旋转，LL右旋转（双旋）

- p是g的left节点，n是p的right节点，此时往n添加节点，这种情况称为LR。
- LR表示失衡节点与添加节点的关系，添加节点在失衡节点的左右。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771423736-51c7f613-5500-411a-8a07-9ee0241763f0.png)
- 如果是LR，首先要进行一次左旋转，将二叉树变为LL。然后再进行一次右旋转，即可使树达到平衡。

#### 5、添加失衡 RL - LL右旋转，RR左旋转（双旋）

- 首先进行右旋转，使树变成RR，然后再进行左旋转，即可达到平衡。
- RL表示失衡节点与添加节点的关系，添加节点在失衡节点的右边的左边。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771424199-d80272ff-bc7b-4f4f-b355-208c5b7f2535.png)

#### 6、删除导致的失衡

- 示例：删除16导致失衡
- 删除节点可能会导致父节点或祖先节点失衡（只有一个节点会失衡），其他节点都不可能失衡。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771425041-f12e8cb7-1627-4cd8-8998-400d6eaa26fb.png)

#### 7、删除失衡 LL - 右旋传（单旋）

- 删除红色节点，g的平衡因子变为2，需要对g进行右旋转。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771425368-9a9d9aba-0919-4c87-acc2-9250e80029e5.png)
- 旋转后，整棵树是否平衡，取决于旋转后子树的高度是否发生变化。其实就取决于绿色节点是否存在。
- 如果绿色节点不存在，那么在右旋转后，子树的高度减少1，可能会导致更高层的祖父节点失衡。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771425368-46ad640c-4b77-4234-b993-d2b355bd4b63.png)
- 更高层的祖先节点失衡，则需要再次恢复平衡，然后又可能导致更高层的祖先节点失衡...
- 极端情况下，所有祖先节点都需要进行恢复平衡的操作，共O(logn)次调整。

### 四、如何调整失衡

#### 1、添加- afterAdd()函数

- 失衡调整应该在添加节点之后。
- 所以我们需要对二叉搜索树的添加方法进行改造，即在完成添加节点后，进行失衡调整。
- 引入afterAdd()函数，当完成添加节点操作后，执行该方法。

```
public void add(E element) {
    ...
    // 添加第一个节点
    if (root == null) {
        ...
        // 新添加节点之后的处理
        afterAdd(root);
    }
    // 添加的不是第一个节点
    else {
        ...
        // 新添加节点之后的处理
        afterAdd(newNode);
    }
}
```

- 接下来我们再看如何实现这个afterAdd(newNode)函数。
- 思路：通过newNode的parent属性，一路往上找，找到高度最低的那个失衡节点，然后对失衡节点进行调整。
- 只要这个高度最低的失衡节点恢复平衡，那么所有的节点都恢复平衡了。

```
protected void afterAdd(Node<E> node) {
    //可能添加新节点之后，整个树没有失衡。
    //所以我们需要一直查找到node.parent == null为止。
    while ((node = node.parent) != null) {
        // 判断节点是否平衡
        if (isBalanced(node)) {
            // 如果是平衡的，更新节点高度
            updateHeight(node);
        } else {
            // 否则，恢复平衡
            rebalance(node);
            // 整棵树恢复平衡
            break;
        }
    }
}
```

#### 2、添加- isBalanced(node)函数

- 在afterAdd(newNode)中，需要实现isBalanced(node)函数，用于判断节点是否平衡，从而决定是更新高度或恢复平衡。
- 判断节点平衡的方式是比较左右子节点高度，所以需要给节点增加一个高度属性。
- 如果节点是平衡的，只需要更新节点高度，通过获取左右子树最大高度 + 1即可。

```
private static class AVLNode<E> extends Node<E> {
    // 高度，默认值为1，因为新节点肯定是叶子节点。
    int height = 1;
		
    public AVLNode(E element, Node<E> parent) {
        super(element, parent);
    }
		
    // 获取节点的平衡因子
    // 左子节点高度减去右子节点高度
    public int balanceFactor() {
        int leftHeight = left == null ? 0 : ((AVLNode<E>)left).height;
        int rightHeight = right == null ? 0 : ((AVLNode<E>)right).height;
            return leftHeight - rightHeight;
    }
        
    // 更新节点高度
    public void updateHeight() {
        int leftHeight = left == null ? 0 : ((AVLNode<E>)left).height;
        int rightHeight = right == null ? 0 : ((AVLNode<E>)right).height;
        // 高度等于左右子树最大高度 + 1
        height = 1 + Math.max(leftHeight, rightHeight);
    }
}

// 判断节点是否平衡
private boolean isBalanced(Node<E> node) {
    // 通过比较该节点，左右节点平衡因子，来判断节点是否平衡。
    return Math.abs(((AVLNode<E>)node).balanceFactor()) <= 1;
}

// 更新某节点高度
private void updateHeight(Node<E> node) {
    ((AVLNode<E>)node).updateHeight();
}
```

#### 3、添加- rebalance(node)函数

- 最后我们还需要实现rebalance(node)函数。
- 能够进入rebalance(node)函数，那么node即为上面分析的失衡的几种情况中的g，g代表grandparent。
- 接下来还要拿到p和n节点。
- p是g左右子树高度最高的子节点。
- n是p左右子树高度最高的子节点。
- 那么我们首先实现一个获取较高子节点的函数。

```
public Node<E> tallerChild() {
    int leftHeight = left == null ? 0 : ((AVLNode<E>)left).height;
    int rightHeight = right == null ? 0 : ((AVLNode<E>)right).height;
    if (leftHeight > rightHeight) return left;
    if (leftHeight < rightHeight) return right;
    // 如果高度一样，断该节点是父节点的左子节点，如果是，则返回left。
    return isLeftChild() ? left : right;
}
```

- 在AVLNode类中增加两个方法用于判断节点是父节点的左子节点或右子节点。

```
private static class AVLNode<E> extends Node<E> {
    ...

    // 判断该节点是父节点的左子节点
    public boolean isLeftChild() {
        return parent != null && this == parent.left;
    }
	
    // 判断该节点是父节点的右子节点
    public boolean isRightChild() {
        return parent != null && this == parent.right;
    }
}
```

- 那么rebalance(node)函数实现如下：

```
/**
* 恢复平衡
* @param grand 高度最低的那个不平衡节点
*/
private void rebalance(Node<E> grand) {
    Node<E> parent = ((AVLNode<E>)grand).tallerChild();
    Node<E> node = ((AVLNode<E>)parent).tallerChild();
    //如果parent是grand的左子节点 L
    if (parent.isLeftChild()) { 
        //并且node是parent的左子节点 LL
        if (node.isLeftChild()) { 
            rotateRight(grand);
        } 
        //并且node是parent的右子节点 LR
        else { 
            rotateLeft(parent);
            rotateRight(grand);
            }
    } 
    //如果parent是grand的右子节点 R
    else { 
        //并且node是parent的左子节点 RL
        if (node.isLeftChild()) { 
            rotateRight(parent);
            rotateLeft(grand);
        } 
        //并且node是parent的右子节点 RR
        else { 
            rotateLeft(grand);
        }
    }
}
```

#### 4、添加- rotateLeft(node) 和- rotateRight(node) 函数

- 最后我们实现rotateLeft()和rotateRight()函数。

```
private void rotateLeft(Node<E> grand) {
    Node<E> parent = grand.right;
    Node<E> child = parent.left;
    grand.right = child;
    parent.left = grand;
    afterRotate(grand, parent, child);
}
	
private void rotateRight(Node<E> grand) {
    Node<E> parent = grand.left;
    Node<E> child = parent.right;
    grand.left = child;
    parent.right = grand;
    afterRotate(grand, parent, child);
}

// 旋转之后，更新各节点信息
private void afterRotate(Node<E> grand, Node<E> parent, Node<E> child) {
    // 让parent成为子树的根节点
    parent.parent = grand.parent;
    if (grand.isLeftChild()) {
        grand.parent.left = parent;
    } else if (grand.isRightChild()) {
        grand.parent.right = parent;
    } else { // grand是root节点
        root = parent;
    }
		
    // 更新child的parent
    if (child != null) {
        child.parent = grand;
    }
		
    // 更新grand的parent
    grand.parent = parent;
		
    // 更新高度
    updateHeight(grand);
    updateHeight(parent);
}
```

#### 5、添加 -afterRemove(node) 函数

- 在节点被删除后，可能导致失衡，所以需要调用afterRemove函数调整失衡。

```
private void remove(Node<E> node) {
    ...
    if (node是度为1的节点) { 
        ...
        // 删除节点之后的处理
        afterRemove(node);
    } else if (node是叶子节点并且是根节点) { 
        ...
        // 删除节点之后的处理
        afterRemove(node);
    } else { 
        //node是叶子节点，但不是根节点
        ...
        // 删除节点之后的处理
        afterRemove(node);
    }
}
```

- 其中updateHeight和rebalance在上面已经实现了。

```
protected void afterRemove(Node<E> node) {
    while ((node = node.parent) != null) {
        if (isBalanced(node)) {
            // 更新高度
            updateHeight(node);
        } else {
            // 恢复平衡
            rebalance(node);
        }
    }
}
```

### 四、示例

- 输入数据：13，14，15，12，11，17，16，8，9，1
- 输入13，14![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771425420-ed8f298a-532b-4036-9c26-b0ef1caa3b0f.png)
- 输入15，导致13不平衡，需要左旋转 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771425467-6af57510-3c4e-453c-b2c4-cee6dd6ad28b.png)
- 输入12![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771426630-c0f16e2e-5a6a-4793-b0dd-143bfc768d05.png)
- 输入11，导致13不平衡，需要右旋转 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771426690-a6f8b260-c6de-48db-a8f8-dc02b3aaae87.png)![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771426960-6a8beacc-c797-4409-96cd-9b54cde9fd02.png)
- 输入17，16![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771426977-b007dec9-1d3b-4847-bb60-7f2ed78b602d.png)
- 那么15，16，17形成RL，需要先对17右旋转，然后对15左旋转。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771426954-5035f13f-d359-4547-8ebd-c075c936b56c.png)
- 输入8，9![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771428112-2cbb3cc9-9160-4c8b-8aad-13a9036d12b5.png)
- 那么11，8，9形成LR，需要先对8左旋转，然后对11右旋转。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771428117-def7321f-ccab-41ea-ad0c-f0bedf40528c.png)
- 输入1，会导致12不平衡。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771428272-c695580a-1ad5-4308-b2c5-99c7033ed704.png)
- 12，9，8形成LL，需要对12右旋转。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771429309-0110a6f6-1165-4849-8e71-5637c8f25b67.png)
- 如果你能理解每一步，说明你已经掌握AVL树。

### 五、总结

- 添加

- 可能会导致所有祖先节点都失衡。
- 但是只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡（仅需O(1)次调整）。

- 删除

- 可能会导致父节点或祖先节点失衡（只有一个节点会失衡）。
- 恢复平衡后，可能会导致更高层的祖先节点失衡（最多需要O(logn)次调整）。

- 平均时间复杂度

- 搜索：O(logn)
- 添加：O(logn)，仅需O(1)次旋转操作。
- 删除：O(logn)，最多需要O(logn)次旋转操作。

### 六、算法

- [平衡二叉树](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fbalanced-binary-tree%2F)

# 11.B树

### 一、B树性质

#### 1、初识B树

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771666000-cf82ba9e-37b1-4b1b-9f2a-fc84a0ae85c3.png)

- B树是一种平衡的多路搜索树，多用于文件系统，数据库的实现。
- B树特点：

- 一个节点可以存储超过2个元素，可以拥有超过2个子节点。
- 拥有二叉树的一些性质。
- 平衡，每个节点的所有子树高度一致。
- 比较矮。

#### 2、m阶B树的性质（m >= 2）

- 假设一个节点存储的元素个数为x。

- 根节点个数：1 <= x <= m-1，三阶B树根节点数大于等于1并且小于等于2。
- 非根节点：(m / 2)(向下取整) - 1 <= x <= m - 1
- 如果有子节点，子节点个数 y = x + 1

- 根节点：2 <= y <= m
- 非根节点：(m / 2)(向下取整) <= y <= m![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771665996-0ece77a2-f431-4442-ae5f-5fb7e71dbfa9.png)

#### 3、B树 VS 二叉搜索树

- 将二叉搜索树的节点合并，可以成为B树。
- 多代（父和子）节点合并，可以获得一个超级节点（类似3阶B树中的18和33节点，23和30节点）。

- 2代合并的超级节点，最多拥有4个子节点（至少是4阶B树）。
- 3代合并的超级节点，最多拥有8个子节点（至少是8阶B树）。
- n代合并的超级节点，最多拥有2^n个子节点（至少是2^n阶B树）。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771665969-4a9a97e7-bee3-4b3f-8583-53463accc0f1.png)

- 将18和33合并，23和30合并，20和21合并，45和47合并，50和52合并。即将一个B树变为二叉搜索树。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771666124-c9d9036b-5818-4779-bfc5-0f8022bbdf48.png)

### 二、B树的操作

#### 1、搜索

- 先在节点内部从小到大搜索元素。
- 如果命中，搜索结束。
- 如果未命中，再去对应的子节点中搜索元素，重复步骤1。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771666667-201afbe4-4048-4958-baf4-4d7259cde051.png)
- 假设搜索72，首先在根节点做比较，72大于40，所以接着在根节点的右子树搜索，72大于60小于80，继续在60和80之间的子树寻找，因为72大于70，所以需要继续往70的右子树寻找，但是右子树为空，所以得出结论72不在该B树上。

#### 2、添加

- 新添加的元素必定是添加到叶子节点。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771670445-266695ef-2237-4bf2-b117-bbf15f86ce39.png)
- 假设插入55，首先在根节点做比较，55大于40，所以接着在根节点的右子树搜索，55小于60，继续在60的左子树寻找，55大于50，所以将55插入在节点50的右侧。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771670207-f9a84390-eb52-4dd9-9fc4-8599e667eb9d.png)
- 假设插入95，首先在根节点做比较，95大于40，所以接着在根节点的右子树搜索，95大于80，继续在80的右子树寻找，95大于90小于100，所以将95插入在节点90和100的中间。

#### 3、上溢

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771670386-9c90a5bc-7755-42a7-a997-91ad8f5963d6.png)

- 假设再插入98呢？（假设这是一颗4阶B树）

- 最右下角的叶子节点的元素个数将超过限制。
- 这种现象可以称之为：上溢（overflow）。

#### 4、上溢的解决

- 假设5阶B树。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771670577-5c6d2d38-00c4-464d-b704-87393f695fee.png)
- 上溢节点的元素个数必然等于m（5）。
- 假设上溢节点最中间元素的位置为k（3）。
- 将k位置的元素向上与父节点合并。
- 将[0,k-1]和[k+1,m-1]位置的元素分裂成2个子节点，这2个子节点的元素个数，必然都不会低于最低限制（m / 2(向下取整) - 1）。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771672687-93a99e3a-c7a8-4732-b4c9-5409596599fe.png)
- 一次分裂完毕后，有可能导致父节点上溢，依然按照上述方法解决。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771671943-f2622e03-0fa4-4ac0-9f5b-a77c3d4d5e84.png)
- 最极端的情况，有可能一致分裂到根节点。
- 添加元素导致的上溢，是唯一一种可能导致B树长高的操作。

#### 5、添加导致上溢的例子

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771672033-56f6adef-0b56-4059-a6d9-ac5c4a81256c.png)

- 插入98![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771672308-d34499e4-2030-4a4a-bf2f-e0c11d8a9b0f.png)
- 98大于根节点，继续往根节点右子树比较，98大于60和80，继续往80右子树比较，98大于90，95，小于100，所以将98插入在95和100中间。
- 插入98之后，90 95 98 100节点溢出，需要上溢，将中间元素95或98向上与父节点合并，将90，98，100节点分裂成2个子节点。
- 插入52![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771672328-4d55b4ce-9076-4367-a33b-8db7cf9eff1d.png)
- 插入54![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771673416-07e49df6-017e-4c68-a1bf-27f89c4e4c95.png)

#### 6、删除

- 假如需要删除的元素在叶子节点中，那么直接删除即可。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771673702-ecb58134-da07-4c48-83f0-bb6457c9b844.png)
- 删除30![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771673780-d72ca7fd-d74a-464f-ba0c-3e29e9d27672.png)
- 假如需要删除的元素在非叶子节点中。

- 先找到前驱或后继元素，覆盖所需删除元素的值。
- 再把前驱或后继元素删除。

- 删除60![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771673894-f7680c27-8dbc-4e8f-ba08-fc7dc61a7c36.png)
- 60的前驱为55，将55从54和55节点中删除，并将55覆盖60。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771673853-f7b931d1-29b8-4f51-8eda-1de04e27c7bd.png)
- 非叶子节点的前驱或后继元素，必定在叶子节点中。

- 所以这里的删除前驱或后继元素，就是最开始提到的情况：删除的元素在叶子节点中。
- 真正的删除元素都发生在叶子节点中。

#### 7、下溢

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771675010-8ce2dfe1-21a8-4187-bb38-87292a920162.png)

- 假设一颗5阶B树，删除22。
- 叶子节点被删除一个元素后，元素个数可能会低于最低限制（>= m/2(向下取整) - 1）。
- 这种现象称为：下溢（underflow）。

#### 8、下溢的解决

- 下溢节点的元素数量必然等于(m/2(向下取整) - 2)。
- 如果下溢节点临近的兄弟节点，有至少m/2(向下取整)个元素，可以向其借一个元素。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771674940-50302058-de5f-44ae-a9f0-10ca12566823.png)
- 绿色节点在删除一个元素后，节点元素个数低于最低限制（>= m/2(向下取整) - 1）。

- 为了使树继续满足B树的要求，需要对绿色节点进行下溢操作。
- 将父节点的元素b插入到下溢节点的0位置（最小位置）。
- 用兄弟节点的元素a（最大的元素）替代父节点的元素b。
- 这种操作其实就是：旋转。
- 注意子节点d也需要调整。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771674970-d4f0e570-e050-43e9-838f-d22fa5dc056d.png)

- 如果下溢节点临近的兄弟节点，只有（>= m/2(向下取整) - 1）个元素。

- 将父节点的元素b挪下来跟左右子节点进行合并。
- 合并后的节点元素个数等于m/2(向下取整) + m/2(向下取整) - 2，不超过m-1。
- 这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直往上传播。

- 添加元素导致的下溢，是唯一一种可能导致B树变矮的操作。

# 12.红黑树

## 一、红黑树（Red Black Tree）

### 1、初识红黑树

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771727264-062b7004-0563-4bd8-99c1-e16ec1f5045f.png)

- 红黑树也是一种自平衡的二叉搜索树，也曾叫做平衡二叉B树。
- 红黑树必须满足以下5条性质：

- 节点是RED或者BLACK
- 根节点是BLACK
- 叶子节点（外部节点，空节点）都是BLACK
- RED节点的子节点都是BLACK

- RED节点的parent都是BLACK
- 从根节点到叶子节点的所有路径上不能有2个连续的RED节点

- 从任意节点到叶子节点的所有路径都包含相同数目的BLACK节点。

- 在添加和删除节点之后，让树依然满足以上5条性质，就可以保证平衡。

// 红黑树继承于二叉平衡搜索树，这里只列出红黑树特有的属性。 public class RBTree<E> extends BBST<E> { private static final boolean RED = false; private static final boolean BLACK = true; @Override protected Node<E> createNode(E element, Node<E> parent) { return new RBNode<>(element, parent); } // 构造一个红黑节点，默认为红色 private static class RBNode<E> extends Node<E> { boolean color = RED; // public RBNode(E element, Node<E> parent) { super(element, parent); } } // 节点染色 private Node<E> color(Node<E> node, boolean color) { if (node == null) return node; ((RBNode<E>)node).color = color; return node; } // 将节点染为红色 private Node<E> red(Node<E> node) { return color(node, RED); } // 将节点染为黑色 private Node<E> black(Node<E> node) { return color(node, BLACK); } // 节点的颜色 private boolean colorOf(Node<E> node) { return node == null ? BLACK : ((RBNode<E>)node).color; } // 是否为黑色节点 private boolean isBlack(Node<E> node) { return colorOf(node) == BLACK; } // 是否为红色节点 private boolean isRed(Node<E> node) { return colorOf(node) == RED; } public boolean isLeftChild() { return parent != null && this == parent.left; } public boolean isRightChild() { return parent != null && this == parent.right; } // 获取兄弟节点 public Node<E> sibling() { if (isLeftChild()) { return parent.right; } if (isRightChild()) { return parent.left; } return null; } } 复制代码protected void afterAdd(Node<E> node) { Node<E> parent = node.parent; // 添加的是根节点 或者 上溢到达了根节点 if (parent == null) { black(node); return; } // 如果父节点是黑色，直接返回 if (isBlack(parent)) return; // 叔父节点 Node<E> uncle = parent.sibling(); // 祖父节点 Node<E> grand = red(parent.parent); if (isRed(uncle)) { // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterAdd(grand); return; } // 叔父节点不是红色 if (parent.isLeftChild()) { // L if (node.isLeftChild()) { // LL black(parent); } else { // LR black(node); rotateLeft(parent); } rotateRight(grand); } else { // R if (node.isLeftChild()) { // RL black(node); rotateRight(parent); } else { // RR black(parent); } rotateLeft(grand); } } 复制代码

### 2、红黑树的等价变化

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771727285-e5545449-1718-4d49-a320-a66cdbf61a3e.png)

- 我们将红黑树的红色节点上移靠近父节点。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771727281-382845b1-4b4f-4048-a91b-6ca8443842e2.png)
- 红黑树和4阶B树具有等价性。
- BLACK节点与它的RED子节点融合在一起，形成1个B树节点。
- 红黑树的BLACK节点数与4阶B树的节点总个数相等。

### 3、红黑树 vs 2-3-4树

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771727295-5cc01a83-62db-428c-abb9-7ca9d7c3fef1.png)

- 如果上图最底层的BLACK节点不存在，那么整颗B树只有一个节点，而且是超级节点。

### 4、红黑树节点关系

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771727310-6e715535-4bdc-421d-bae8-fc39df7b9e33.png)

- 父节点（parent）

- 55是38和80的父节点，38是25和46的父节点。

- 兄弟节点（sibling）

- 25和46是兄弟节点，76和88是兄弟节点。

- 叔父节点（parent的兄弟节点）

- 25和46的叔父节点是80。

- 祖父节点（parent的父节点）

- 25的祖父节点是55。

## 二、红黑树的实现

### 1、构造方法

- 除了构造函数，还提供一些辅助函数，在之后会使用。

```
// 红黑树继承于二叉平衡搜索树，这里只列出红黑树特有的属性。
public class RBTree<E> extends BBST<E> {
    private static final boolean RED = false;
    private static final boolean BLACK = true;
	
    @Override
    protected Node<E> createNode(E element, Node<E> parent) {
        return new RBNode<>(element, parent);
    }

    // 构造一个红黑节点，默认为红色
    private static class RBNode<E> extends Node<E> {
        boolean color = RED; //
        public RBNode(E element, Node<E> parent) {
            super(element, parent);
        }
    }
	
    // 节点染色
    private Node<E> color(Node<E> node, boolean color) {
        if (node == null) return node;
        ((RBNode<E>)node).color = color;
        return node;
    }
	
    // 将节点染为红色
    private Node<E> red(Node<E> node) {
        return color(node, RED);
    }
	
    // 将节点染为黑色
    private Node<E> black(Node<E> node) {
        return color(node, BLACK);
    }
	
    // 节点的颜色
    private boolean colorOf(Node<E> node) {
        return node == null ? BLACK : ((RBNode<E>)node).color;
    }
	
    // 是否为黑色节点
    private boolean isBlack(Node<E> node) {
        return colorOf(node) == BLACK;
    }
	
    // 是否为红色节点
    private boolean isRed(Node<E> node) {
        return colorOf(node) == RED;
    }
    
    public boolean isLeftChild() {
        return parent != null && this == parent.left;
    }
		
    public boolean isRightChild() {
        return parent != null && this == parent.right;
    }
	
    // 获取兄弟节点	
    public Node<E> sibling() {
        if (isLeftChild()) {
            return parent.right;
        }
			
        if (isRightChild()) {
            return parent.left;
        }
        return null;
    }
}
```

### 2、添加

- 通过之前的学习，我们知道：

- B树中，新元素必定是添加到叶子节点中。
- 4阶B树所有节点的元素个数x，都符合1 <= x <= 3。

- 建议新添加的节点默认为RED，这样能够让红黑树的性质尽快满足（初识红黑树中的5条性质，除了性质4不一定满足）。
- 如果添加的是根节点，染成BLACK即可。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771730787-491dcf7d-aeaa-4378-8e68-03eb6005a3e0.png)
- 因为新元素必定是添加到叶子节点中，所以红黑树的添加一共有12种情况，分为17的左右，33的左右，46的左，50的左右，72的左右，76的右，88的左右。
- 其中4种是parent为BLACK的情况，有8种是parent为RED的情况。

#### 2.1 parent为BLACK

- 有4种情况满足红黑树的性质4：parent为BLACK。
- 并且同样也满足4阶B树的性质，因此不用做任何额外处理。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771730861-2c1ed494-0bc8-409b-8eaf-d0210b87a4fd.png)

#### 2.2 parent为RED（Double Red）

- 这8种情况需要在添加之后修复红黑树。
- 其中前4种属于B树节点上溢的情况。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771731061-829892d9-eaa7-43e6-b23e-a224ec42b441.png)

#### 2.2.1 添加-修复性质4-LL\RR

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771731066-0e3da902-9466-4763-bb2a-a80d851e937e.png)

- 首先看52和60，这两种情况分别属于RR和LL。
- 判定条件：uncle不是RED。
- 操作步骤：

1. parent染成BLACK，grand染成RED。
2. grand进行单旋操作。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771731121-8310985c-a4fb-4464-85a1-fb4324cff8ab.png)

#### 2.2.2 添加-修复性质4-LR\RL

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771732324-c96fbde2-9adf-4905-8884-40f7f5622247.png)

- 看48和74，这两种情况属于LR和RL。
- 判定条件：uncle不是RED。
- 操作步骤：

1. 自己染成BLACK，grand染成RED。
2. 进行双旋操作。
3. 如果是LR，parent左旋转，grand右旋转。
4. 如果是RL，parent右旋转，grand左旋转。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771732668-906fb563-3f9b-4374-865e-13ea9fdea312.png)

#### 2.2.3 添加-修复性质4-上溢-LL

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771732653-ac168798-fc37-4e2a-95d2-229f68cfaf66.png)

- 现在我们来添加10，10添加之后会导致上溢，这种情况属于LL。
- 判定条件：uncle是RED。
- 操作步骤：

1. parent，uncle染成BLACK，成为独立节点。
2. grand向上合并，染成RED，当作是新添加的节点进行处理。
3. grand向上合并时，可能继续发生上溢，若上溢持续到根节点，只需将根节点染成BLACK。

- LL的情况不需要旋转，只需要染色。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771732731-f75cc7a8-680e-4310-924a-3f5262a3a70d.png)

#### 2.2.4 添加-修复性质4-上溢-RR

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771732776-c01c7670-36fc-424b-a2dc-345478f2a1bc.png)

- 判定条件：uncle是RED。
- 操作步骤：

1. parent，uncle染成BLACK，成为独立节点。
2. grand向上合并，染成RED，当作是新添加的节点进行处理。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771734129-577d9fab-98f4-42fa-b13f-83bc12d9e253.png)

#### 2.2.5 添加-修复性质4-上溢-LR

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771734400-3c91273f-b971-486a-9b6d-e71810113b74.png)

- 判定条件：uncle是RED。
- 操作步骤：

1. parent，uncle染成BLACK，成为独立节点。
2. grand向上合并，染成RED，当作是新添加的节点进行处理。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771734617-197dffd2-a754-4094-adc9-ea094c07dcd9.png)

#### 2.2.6 添加-修复性质4-上溢-RL

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771734846-23931169-d834-40f5-8762-ffebd0aa3488.png)

- 判定条件：uncle是RED。
- 操作步骤：

1. parent，uncle染成BLACK，成为独立节点。
2. grand向上合并，染成RED，当作是新添加的节点进行处理。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771734886-d571fbc5-4579-4ed3-bd68-f2d7ba01c763.png)

#### 2.3 添加总结

- 添加一共有12种情况。
- 其中有4种情况，添加之后父节点为黑色，添加之后不用做处理。依然满足性质4。
- 另外8种情况，添加之后父节点为红色，不满足性质4，需要进行双红修复处理。
- 修复分为两种情况：

- uncle不是RED：

- LL\RR，让祖父节点进行单旋转，染成红色，让父节点成为中心，并染成黑色。
- LR\RL，让祖父节点和父节点进行旋转，让新添加成员成为中心节点，染成黑色，祖父节点染成红色。

- uncle是RED：

- 父节点，叔父节点染成黑色。
- 祖父节点染成红色，并上溢。

#### 2.4 添加实现

- rotateLeft，rotateRight函数实现请查看[平衡二叉搜索树（AVL）](https://juejin.cn/post/6844904032973094926#heading-18)

```
protected void afterAdd(Node<E> node) {
    Node<E> parent = node.parent;
    // 添加的是根节点 或者 上溢到达了根节点
    if (parent == null) {
        black(node);
        return;
    }
    // 如果父节点是黑色，直接返回
    if (isBlack(parent)) return;
		
    // 叔父节点
    Node<E> uncle = parent.sibling();
    // 祖父节点
    Node<E> grand = red(parent.parent);
    if (isRed(uncle)) { // 叔父节点是红色【B树节点上溢】
        black(parent);
        black(uncle);
        // 把祖父节点当做是新添加的节点
        afterAdd(grand);
        return;
    }
		
    // 叔父节点不是红色
    if (parent.isLeftChild()) { // L
        if (node.isLeftChild()) { // LL
            black(parent);
        } else { // LR
            black(node);
            rotateLeft(parent);
        }
        rotateRight(grand);
    } else { // R
        if (node.isLeftChild()) { // RL
            black(node);
            rotateRight(parent);
        } else { // RR
            black(parent);
        }
        rotateLeft(grand);
    }
}
```

### 3、删除

- B树中，最后真正被删除的元素都在叶子节点上。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771736116-de24e721-e63a-4704-b8aa-898015b99770.png)
- 删除分为删除RED节点和删除BLACK节点两种情况。
- 删除RED节点，直接删除即可，不用做任何调整。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771736379-ae15db91-24ba-4c99-8fe0-a8ff93edfc88.png)
- 删除BLACK节点分为3种情况。

- 拥有2个RED子节点的BLACK节点，例如25。

- 不可能被直接删除，因为会找它的前驱或后继子节点替代删除，因此不用考虑这种情况。

- 拥有1个RED子节点的BLACK节点，例如46，76。
- BLACK叶子节点，例如88。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771736497-2e69e0c7-170f-4324-b732-a133712668d9.png)

#### 3.1 删除拥有1个RED子节点的BLACK节点

- 判定条件：删除指定节点后，用以代替的子节点是RED。
- 将替代的子节点染成BLACK即可保持红黑树的性质。
- 例如删除50和72。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771736579-f425efc5-940b-412c-8af8-efbfcc39a106.png)

#### 3.2 删除 - BLACK叶子节点 - sibling为BLACK

- BLACK叶子节点被删除后，会导致B树节点下溢（比如删除88）。

#### 3.2.1 sibling至少有1个RED子节点

- 如果sibling至少有1个RED子节点：

- 进行旋转操作。
- 旋转之后的中心节点继承parent的颜色。
- 旋转之后的左右节点染为BLACK。

- 如果sibling有2个RED子节点，那么可以选择删除其左子节点或右子节点，删除左子节点少做一次旋转。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771736752-d10a2f35-e392-4143-b7b9-6fdfa2f1e81e.png)
- 举例：

- 删除88。
- 76左旋转，80右旋转。
- 中心节点(78)继承parent的颜色(80)。
- 80旋转下去之后，染成BLACK。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771737903-d3a32a66-b1a7-48aa-8abc-8ec9164a0d38.png)

#### 3.2.2 sibling没有RED子节点

- 如果sibling没有1个RED子节点：

- 将sibling染成RED，parent染成BLACK即可修复红黑树性质。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771737940-1724a53c-2a21-40bc-bf9d-4737ef88e1d3.png)

- 如果parent是BLACK

- 会导致parent也下溢。
- 这时只需要把parent当作被删除的节点处理即可，相当于递归调用afterremove。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771738017-85035693-131b-404e-8aba-745dea0bc82e.png)

#### 3.2.3 sibling为RED

- 如果sibling是RED：

- sibling染成BLACK，parent染成RED，进行旋转。
- 于是又回到sibling是BLACK的情况。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771738136-8c4a4280-2db8-46a0-b859-7027bf2a5301.png)

  

作者：逍遥归来  
链接：https://juejin.cn/post/6844904036747968525  
来源：稀土掘金  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 13.集合（Set）与映射（Map）

### 一、集合（Set）

- 不存放重复的元素
- 常用于去重

- 存放新增IP，统计新增IP量
- 存放词汇，统计词汇量

- 集合的内部实现能使用哪些数据结构？

- 动态数组
- 链表
- 二叉搜索树（AVL树，红黑树）

### 二、集合的接口设计

```
public interface Set<E> {
    int size();
    boolean isEmpty();
    void clear();
    boolean contains(E element);
    void add(E element);
    void remove(E element);
    void traversal(Visitor<E> visitor); //遍历集合
	
    public static abstract class Visitor<E> {
        boolean stop;
        public abstract boolean visit(E element);
    }
}
```

### 三、集合的实现

#### 1、通过链表实现集合

- 复杂度为O(n)

```
public class ListSet<E> implements Set<E> {
    private List<E> list = new LinkedList<>();

    @Override
    public int size() {
        return list.size();
    }

    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }

    @Override
    public void clear() {
        list.clear();
    }

    @Override
    public boolean contains(E element) {
        return list.contains(element);
    }

    @Override
    public void add(E element) {
        int index = list.indexOf(element); // 获取该元素的索引
        if (index != List.ELEMENT_NOT_FOUND) { // 存在就覆盖
            list.set(index, element);
        } else { // 不存在就添加
            list.add(element);
        }
    }

    @Override
    public void remove(E element) {
        int index = list.indexOf(element);
        if (index != List.ELEMENT_NOT_FOUND) {
            list.remove(index);
        }   
    }

    @Override
    public void traversal(Visitor<E> visitor) {
        if (visitor == null) return;
		
        int size = list.size();
        for (int i = 0; i < size; i++) {
            if (visitor.visit(list.get(i))) return;
        }
    }
}
```

#### 2、通过红黑树实现集合

- 复杂度为O(logn)
- **元素必须具备可比较性，否则只能使用哈希表**

```
public class TreeSet<E> implements Set<E> {
    private RBTree<E> tree;
	
    public TreeSet() {
        this(null);
    }
	
    public TreeSet(Comparator<E> comparator) {
        tree = new RBTree<>(comparator);
    }
	
    @Override
    public int size() {
        return tree.size();
    }

    @Override
    public boolean isEmpty() {
        return tree.isEmpty();
    }

    @Override
    public void clear() {
        tree.clear();
    }

    @Override
    public boolean contains(E element) {
        return tree.contains(element);
    }

    @Override
    public void add(E element) {
        tree.add(element);// 红黑树默认具有去重功能，直接添加即可。
    }

    @Override
    public void remove(E element) {
        tree.remove(element);
    }

    @Override
    public void traversal(Visitor<E> visitor) {
        tree.inorder(new BinaryTree.Visitor<E>() {
            @Override
            public boolean visit(E element) {
                return visitor.visit(element);
            }
        });
    }
}
```

### 四、映射（Map）

- Map在有些编程语言中也叫做字典（dictionary）
- Map的每一个key是唯一的 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771811931-92952537-7286-44a7-9fd6-817d037632cd.png)
- 类似Set，Map可以直接利用之前学习的链表，二叉搜索树（AVL树，红黑树）等数据结构来实现。
- 添加，删除，搜索的时间复杂度是O(logn)
- 特点

- Key必须具备可比较性。
- 元素的分布是有顺序的（key大的在右边，小的在左边）。

- 在实际应用中：

- map中的存储的元素不需要讲究顺序。
- map中的key不需要具备可比较性。
- 不考虑顺序和key的可比较性，map有更优的实现方案，平均时间复杂度可达到O(1)，那就是采取哈希表来实现map。

### 五、映射的接口设计

- 可以在Map的基础上实现一个TreeMap

```
public interface Map<K, V> {
    int size();
    boolean isEmpty();
    void clear();
    V put(K key, V value); //添加元素
    V get(K key);
    V remove(K key);
    boolean containsKey(K key); //查找key是否存在
    boolean containsValue(V value); //查找value是否存在
    void traversal(Visitor<K, V> visitor); //元素遍历
	
    public static abstract class Visitor<K, V> {
        boolean stop;
        public abstract boolean visit(K key, V value);
    }
}
```

### 六、映射的实现（TreeMap）

- 思路是将映射直接通过红黑树来实现，而不仅仅是通过红黑树存储映射的值。

#### 1、声明节点

```
private static class Node<K, V> {
    K key;
    V value;
    boolean color = RED;
    Node<K, V> left;
    Node<K, V> right;
    Node<K, V> parent;
    public Node(K key, V value, Node<K, V> parent) {
        this.key = key;
        this.value = value;
        this.parent = parent;
    }
		
    public boolean isLeaf() {
        return left == null && right == null;
    }
		
    public boolean hasTwoChildren() {
        return left != null && right != null;
    }
		
    public boolean isLeftChild() {
        return parent != null && this == parent.left;
    }
		
    public boolean isRightChild() {
        return parent != null && this == parent.right;
    }
		
    public Node<K, V> sibling() {
        if (isLeftChild()) {
            return parent.right;
        }
			
        if (isRightChild()) {
            return parent.left;
        }
        return null;
        }
    }
```

#### 2、put函数实现

```
@Override
public V put(K key, V value) { 
    keyNotNullCheck(key); // key不能为空
		
    // 添加第一个节点
    if (root == null) {
        root = new Node<>(key, value, null);
        size++;

        // 新添加节点之后的处理
        afterPut(root); //修复红黑树性质
        return null;
    }
		
    // 添加的不是第一个节点
    // 找到父节点
    Node<K, V> parent = root;
    Node<K, V> node = root;
    int cmp = 0;
    do {
        cmp = compare(key, node.key); //比较传入的key与原节点key
        parent = node;
        if (cmp > 0) {
            node = node.right;
        } else if (cmp < 0) {
            node = node.left;
        } else { // 相等
            node.key = key; //覆盖key
            V oldValue = node.value;
            node.value = value; //覆盖value
            return oldValue; //返回原节点值
        }
    } while (node != null);

        // 看看插入到父节点的哪个位置
        Node<K, V> newNode = new Node<>(key, value, parent);
        if (cmp > 0) {
            parent.right = newNode;
        } else {
            parent.left = newNode;
        }
        size++;
		
        // 新添加节点之后的处理
        afterPut(newNode);
        return null; //新添加节点，返回空。
    }
```

#### 3、get函数实现

- 通过key先找到node节点，然后再返回节点的值。

```
@Override
public V get(K key) {
    Node<K, V> node = node(key);
    return node != null ? node.value : null;
}

private Node<K, V> node(K key) {
    Node<K, V> node = root;
    while (node != null) {
        int cmp = compare(key, node.key);
        if (cmp == 0) return node;
        if (cmp > 0) {
            node = node.right;
        } else { // cmp < 0
            node = node.left;
        }
    }
    return null;
}
```

#### 4、remove函数实现

- 先通过key找到节点，然后再删除节点。

```
@Override
public V remove(K key) {
    return remove(node(key));
}
	
private V remove(Node<K, V> node) {
    if (node == null) return null;
		
    size--;
		
    V oldValue = node.value;
		
    if (node.hasTwoChildren()) { // 度为2的节点
        // 找到后继节点
        Node<K, V> s = successor(node);
        // 用后继节点的值覆盖度为2的节点的值
        node.key = s.key;
        node.value = s.value;
        // 删除后继节点
        node = s;
    }
		
    // 删除node节点（node的度必然是1或者0）
    Node<K, V> replacement = node.left != null ? node.left : node.right;
		
    if (replacement != null) { // node是度为1的节点
        // 更改parent
        replacement.parent = node.parent;
        // 更改parent的left、right的指向
        if (node.parent == null) { // node是度为1的节点并且是根节点
            root = replacement;
        } else if (node == node.parent.left) {
            node.parent.left = replacement;
        } else { // node == node.parent.right
            node.parent.right = replacement;
        }
			
        // 删除节点之后的处理
        afterRemove(replacement);
    } else if (node.parent == null) { // node是叶子节点并且是根节点
        root = null;
    } else { // node是叶子节点，但不是根节点
        if (node == node.parent.left) {
            node.parent.left = null;
        } else { // node == node.parent.right
            node.parent.right = null;
        }
        // 删除节点之后的处理
        afterRemove(node);
    }
    return oldValue;
}
```

#### 5、contains函数实现

- 因为value没有可比较性，所以containsValue只有通过树的遍历来查找value是否存在。

```
@Override
public boolean containsKey(K key) {
    return node(key) != null;
}

@Override
public boolean containsValue(V value) {
    if (root == null) return false;
	
    //层序遍历
    Queue<Node<K, V>> queue = new LinkedList<>();
    queue.offer(root);
		
    while (!queue.isEmpty()) {
        Node<K, V> node = queue.poll();
        if (valEquals(value, node.value)) return true;
			
        if (node.left != null) {
            queue.offer(node.left);
        }
			
        if (node.right != null) {
            queue.offer(node.right);
        }
    }
    return false;
}

private boolean valEquals(V v1, V v2) {
    return v1 == null ? v2 == null : v1.equals(v2);
}
```

#### 6、traversal函数实现

- 中序遍历

```
@Override
public void traversal(Visitor<K, V> visitor) {
    if (visitor == null) return;
    traversal(root, visitor);
}
	
private void traversal(Node<K, V> node, Visitor<K, V> visitor) {
    if (node == null || visitor.stop) return;
		
    traversal(node.left, visitor);
    if (visitor.stop) return;
    visitor.visit(node.key, node.value);
    traversal(node.right, visitor);
}
```

### 七、leetcode算法题

- [两个数组的交集](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fintersection-of-two-arrays%2F)

# 14.哈希表（HashTable）

### 一、哈希表（Hash Table）

#### 1、概念

- 哈希表也叫做散列表。
- 哈希表的原理： ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771997623-52545942-cbe3-45f5-b15b-f4db7aa3a7af.png)
- 利用哈希函数生成key对应的index，时间复杂度O(1)。
- 根据index(索引)操作定位数组元素，时间复杂度O(1)。
- 哈希表的空间换时间的典型应用。

#### 2、哈希冲突

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771997627-4aca5d4c-e462-4e4e-82f9-8dec0a5cc03e.png)

- 哈希冲突也叫做哈希碰撞。

- 2个不同的key，经过哈希函数计算出相同的结果。
- key1 != key2，hash(key1) = hash(key2)

- 解决哈希冲突的常见方法

- 按照一定规则（线性探测，平方探测）向其他地址探测，直到遇到空桶。（开放定址法）
- 设计多个哈希函数。（再哈希法）
- 通过链表将同一index的元素串起来。（链地址法） ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771997615-21c9dff5-52a9-4dfb-9962-25530230df33.png)

#### 3、JDK1.8的哈希冲突解决方案

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771997619-3f5797ad-281a-4ab9-ab69-92d862e04b7a.png)

- 默认使用单向链表将元素串起来。
- 当单向链表的节点数量大于8时，将转为红黑树来存储元素。在调整容量时，如果树节点数量小于6，又会转为单向链表。
- 为什么不使用双向链表，而是单向链表？

- 每次查找都要从单向链表头节点开始遍历，首先确认链表中是否已有该元素，若没有则插入。
- 单向链表比双向链表少一个指针，可以节省内存空间。

#### 4、哈希函数

- 哈希表中哈希函数的实现步骤：

- 生成key的哈希值（必须是整数）。
- 再让key的哈希值跟数组的大小进行相关运算，生成一个索引值。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771997630-e7c20485-b0b1-42e6-a5d0-67a1f50a4914.png)

- 为了提高效率，可以使用&与运算取代%运算（前提将数组的长度设计为2^n）。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771999720-3d9f8423-ae18-419e-bbe8-9fbff1d85bfe.png)
- 因为数组长度为为2^n，转换为二进制是10000或100之类的值，table.length - 1的结果转换成二进制即为01111或011之类的值。
- 将hash_code(key)和01111做与运算，比如10100&00111，结果为00101，值肯定小于00111，且最小为00000，最大为00111。
- 结论就是无论hash_code(key)有多大，当它与上table.length - 1，它的值都是在0到table.length - 1之间。
- 良好的哈希函数是让哈希值更加均匀的分布，减少哈希冲突次数，提升哈希表的性能。

#### 5、如何生成hash_code(key)

- key的常见种类可能是有整数，浮点数，字符串，自定义对象。
- 不同种类的key，哈希值的生成方式不一样，但目标是一致的：

- 尽量让每个key的哈希值是唯一的。
- 尽量让key的所有信息参与运算。

##### 5.1、整数的哈希值

- 整数的哈希值则直接为它的值，比如10的哈希值就是10。

##### 5.2、浮点数的哈希值

- 浮点数的哈希值是将存储的二进制格式转为整数值。
- 比如10.6在内存中是01010010101，那么将01010010101转为整数即为1093245338。

##### 5.2、Long和Double的哈希值

- java中的hash值必须是整数，即是32位。
- Long和Double都是64位，可以将value的高32位和低32位混合计算出32位的值，然后再用value的值与这个32位值做亦或运算（相同为0，不同为1）。
- 亦或运算之后再将64位的结果强制转换为32位。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668771999985-28432c3e-84fd-4ec3-93e9-e909bc3d7d34.png)![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772000306-d1ba7d1a-b6c7-4814-a252-a9f7d3943bf4.png)
- 最终获取的值是橙色部分。
- 这样即充分利用所有信息计算出了哈希值。

##### 5.3、字符串的哈希值

- 比如字符串jack，由j、a、c、k四个字符组成（字符的本质就是一个整数，因为可以转换成ascII码）
- 因此jack的哈希值可以表示为j*n^3 + a*n^2 + c*n^1 + k*n^0。

##### 5.4、自定义对象的哈希值

- 默认情况下，自定义对象的哈希值是跟内存地址有关系的。
- 所以两个对象即使各个属性值都相同，但他们的哈希值是不同的，如果用一个字典保存这两个对象，字典内会有两个对象。
- 如何能让字典中只保存相同对象中的一个呢？这就需要我们重写hashCode函数。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772001724-eac1902c-7eba-48e9-bc47-3052a49f4486.png)
- 重写的hashCode函数，我们将对象所有属性都计算进来，这样即充分利用所有信息计算出了哈希值。
- 当哈希冲突的时候，我们会调用对象的equals函数进行对象间的比较。如果两个对象相同，则覆盖，如果不同，则加入到value链表中。所以我们也需要重写equals函数。
- 哈希值相同的两个对象，不一定相等，只能说两个对象通过hashCode算出的索引值相同。

##### 5.5、自定义对象存储举例

- 假设我们创建三个对象存入map中，并且p1和test的哈希值相同： ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772001654-65769eb2-d8f5-4c84-9baf-ec6a1902da68.png)
- 当存入p1和test时，map中的结构如下： ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772003071-deba206d-c797-4db7-b8d2-e9c082eb3e1d.png)
- 当存入p2时，会调用equals函数比较p1和p2 ，因为重写了equals函数，所以会返回true，在map中，当确认两个对象相等时，则会执行替换： ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772003663-849bedcb-e982-49d4-98b0-405a6904b151.png)

### 二、哈希表的接口设计（HashMap）

- 用Map实现一个哈希表（HashMap）
- 通过一个数组保存key（索引）。
- key对应的value（数据）则直接保存红黑树的根节点。

```
public class HashMap<K, V> implements Map<K, V> {
    private Node<K, V>[] table;
    protected static class Node<K, V> //声明一个节点类
    private static final int DEFAULT_CAPACITY = 1 << 4; //数组默认长度，16

    public HashMap() {
        table = new Node[DEFAULT_CAPACITY]; //建议长度为2^n
    }
}
```

### 三、哈希表的实现（HashMap）

#### 1、声明节点

```
protected static class Node<K, V> {
    int hash;
    K key;
    V value;
    boolean color = RED;
    Node<K, V> left;
    Node<K, V> right;
    Node<K, V> parent;
    public Node(K key, V value, Node<K, V> parent) {
        this.key = key;
        int hash = key == null ? 0 : key.hashCode();
        this.hash = hash ^ (hash >>> 16);
        this.value = value;
        this.parent = parent;
	}
		
    public boolean hasTwoChildren() {
        return left != null && right != null;
    }
		
    public boolean isLeftChild() {
        return parent != null && this == parent.left;
    }
		
    public boolean isRightChild() {
        return parent != null && this == parent.right;
    }
		
    public Node<K, V> sibling() {
        if (isLeftChild()) { return parent.right; }
        if (isRightChild()) { return parent.left; }
        return null;
    }
		
    @Override
    public String toString() {
        return "Node_" + key + "_" + value;
    }
}
```

#### 2、clean实现

- 遍历数组，清空数组的每一个节点。

```
@Override
public void clear() {
    if (size == 0) return;
    size = 0;
    for (int i = 0; i < table.length; i++) {
        table[i] = null;
    }
}
```

#### 3、put实现

- 在进行插入操作时，通过比较key和key.parent的哈希值大小，来决定插入位置。
- 如果哈希值相同，则比较equals。
- 如果equals相同，则比较类名。
- 如果类名相同（同一种类型），则查看是否实现comparable，如果实现，则直接通过该函数比较。
- 如果相同类型，不具有可比较性，或其中一个数据为空，则比较内存地址。
- 直接比较内存地址会导致结果不稳定，应该先扫码树中是否有该值，如果没有，再比较内存地址。

```
@Override
public V put(K key, V value) {
    resize();
		
    int index = index(key); // 获取key对应的索引
    Node<K, V> root = table[index]; // 取出index位置的红黑树根节点
    if (root == null) { // 如果根节点为空
        root = createNode(key, value, null);
        table[index] = root;
        size++;
        fixAfterPut(root);
        return null;
    }
		
    //  如果根节点不为空，添加新的节点到红黑树上面
    Node<K, V> parent = root;
    Node<K, V> node = root;
    int cmp = 0;
    K k1 = key;
    int h1 = hash(k1);
    Node<K, V> result = null;
    boolean searched = false; // 是否已经搜索过这个key
    do {
        parent = node;
        K k2 = node.key;
        int h2 = node.hash;
        // 根据哈希值来进行比较，大的放右边，小的放左边。
        if (h1 > h2) {
            cmp = 1;
        } else if (h1 < h2) {
            cmp = -1;
        } else if (Objects.equals(k1, k2)) {
            cmp = 0;
        } else if (k1 != null && k2 != null 
            && k1 instanceof Comparable
            && k1.getClass() == k2.getClass()
            && (cmp = ((Comparable)k1).compareTo(k2)) != 0) {
        } else if (searched) { // 已经扫描了
            cmp = System.identityHashCode(k1) - System.identityHashCode(k2);
        } else { // searched == false; 还没有扫描，然后再根据内存地址大小决定左右
	    if ((node.left != null && (result = node(node.left, k1)) != null)
	    || (node.right != null && (result = node(node.right, k1)) != null)) {
	        // 已经存在这个key
	        node = result;
	        cmp = 0;
	    } else { // 不存在这个key
	        searched = true;
	        cmp = System.identityHashCode(k1) - System.identityHashCode(k2); //根据内存地址计算出的hashcode
	    }
    }
			
    if (cmp > 0) { // 大于
        node = node.right;
    } else if (cmp < 0) { //小于
        node = node.left;
    } else { // 相等
        V oldValue = node.value;
        node.key = key;
        node.value = value;
        node.hash = h1;
        return oldValue;
    }
} while (node != null);

// 看看插入到父节点的哪个位置
Node<K, V> newNode = createNode(key, value, parent);
if (cmp > 0) {
    parent.right = newNode;
} else {
    parent.left = newNode;
}
size++;
		
// 新添加节点之后的处理
fixAfterPut(newNode);
return null;
}

/**
* 根据key生成对应的索引（在桶数组中的位置）
*/
private int index(K key) {
    return hash(key) & (table.length - 1); //先求哈希值，再做位运算
}

private int hash(K key) {
    if (key == null) return 0;
    int hash = key.hashCode();
    return hash ^ (hash >>> 16); //高16位与低16位做一次运算
}
```

#### 3、get实现

- 首先确定key的索，然后再寻找索引下的树。

```
@Override
public V get(K key) {
    Node<K, V> node = node(key);
    return node != null ? node.value : null;
}

private Node<K, V> node(K key) {
    //根据key生成对应的索引
    //根据索引在数组中找到根节点。
    Node<K, V> root = table[index(key)];
    return root == null ? null : node(root, key); 
}

private Node<K, V> node(Node<K, V> node, K k1) {
    int h1 = hash(k1);
    // 存储查找结果
    Node<K, V> result = null;
    int cmp = 0;
    while (node != null) {
        K k2 = node.key;
        int h2 = node.hash;
        // 先比较哈希值
        if (h1 > h2) {
            node = node.right;
        } else if (h1 < h2) {
            node = node.left;
        } else if (Objects.equals(k1, k2)) { //可比较性
            return node;
        } else if (k1 != null && k2 != null 
                && k1 instanceof Comparable
                && k1.getClass() == k2.getClass()
                && (cmp = ((Comparable)k1).compareTo(k2)) != 0) {
				node = cmp > 0 ? node.right : node.left;
        } 
        // 走到这里，表示哈希值相等，不具备可比较性，也不 equals
        else if (node.right != null && (result = node(node.right, k1)) != null) { //先找右子树
            return result;
        } else { // 再去左边扫码
            node = node.left;
        }
    }
    return null;
}
```

#### 4、remove实现

```
@Override
public V remove(K key) {
    return remove(node(key));
}

protected V remove(Node<K, V> node) {
    if (node == null) return null;
		
    Node<K, V> willNode = node;
		
    size--;
		
    V oldValue = node.value;
		
    if (node.hasTwoChildren()) { // 度为2的节点
        // 找到后继节点
        Node<K, V> s = successor(node);
        // 用后继节点的值覆盖度为2的节点的值
        node.key = s.key;
        node.value = s.value;
        node.hash = s.hash;
        // 删除后继节点
        node = s;
    }
		
    // 删除node节点（node的度必然是1或者0）
    Node<K, V> replacement = node.left != null ? node.left : node.right;
    int index = index(node);
		
    if (replacement != null) { // node是度为1的节点
        // 更改parent
        replacement.parent = node.parent;
        // 更改parent的left、right的指向
        if (node.parent == null) { // node是度为1的节点并且是根节点
            table[index] = replacement;
        } else if (node == node.parent.left) {
            node.parent.left = replacement;
        } else { // node == node.parent.right
            node.parent.right = replacement;
        }
        // 删除节点之后的处理
        fixAfterRemove(replacement);
    } else if (node.parent == null) { // node是叶子节点并且是根节点
        table[index] = null;
    } else { // node是叶子节点，但不是根节点
        if (node == node.parent.left) {
            node.parent.left = null;
        } else { // node == node.parent.right
            node.parent.right = null;
        }
        // 删除节点之后的处理
        fixAfterRemove(node);
    }
		
    // 交给子类去处理
    afterRemove(willNode, node);
    return oldValue;
}
```

#### 5、containsValue实现

- 检测哈希表中是否存在某值，只有遍历每一个树，使用层序遍历实现。

```
@Override
public boolean containsValue(V value) {
    if (size == 0) return false;
    Queue<Node<K, V>> queue = new LinkedList<>();
    for (int i = 0; i < table.length; i++) {
        if (table[i] == null) continue;
			
        queue.offer(table[i]);
        while (!queue.isEmpty()) {
            Node<K, V> node = queue.poll();
            if (Objects.equals(value, node.value)) return true;
				
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
    return false;
}
```

#### 6、扩容

- 当哈希表的table数组中添加元素过多后，哈希冲突概率增大，效率变低。所以要根据装填因子判断是否需要扩容。
- 装填因子：节点总数量 / 哈希表桶数组长度，也叫做负载因子。
- 在JDK1.8的HashMap中，如果装填因子超过0.75，就扩容为原来的2倍。
- 如果装填因子超过0.75，就将数组长度扩大为原来的两倍，并将原来的数据迁移进新数组。
- 扩容之后，原来数据算出的节点值就有可能不一样了（保持不变或index = index + 旧容量），因为节点的计算需要涉及到table.length。

```
private void resize() {
    // 装填因子 <= 0.75
    if (size / table.length <= DEFAULT_LOAD_FACTOR) return;
		
    Node<K, V>[] oldTable = table;//保留旧的数组
    table = new Node[oldTable.length << 1];//将数组长度变为原来的2倍

    //层序遍历
    Queue<Node<K, V>> queue = new LinkedList<>();
    for (int i = 0; i < oldTable.length; i++) {
        if (oldTable[i] == null) continue;
			
        queue.offer(oldTable[i]);
        while (!queue.isEmpty()) {
            Node<K, V> node = queue.poll();
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
				
            // 挪动代码得放到最后面
            moveNode(node);
        }
    }
}

private void moveNode(Node<K, V> newNode) {
    // 重置节点属性
    newNode.parent = null;
    newNode.left = null;
    newNode.right = null;
    newNode.color = RED;
		
    int index = index(newNode);
    // 取出index位置的红黑树根节点
    Node<K, V> root = table[index];
    if (root == null) {
        root = newNode;
        table[index] = root;
        fixAfterPut(root);
        return;
    }
		
    // 添加新的节点到红黑树上面
    Node<K, V> parent = root;
    Node<K, V> node = root;
    int cmp = 0;
    K k1 = newNode.key;
    int h1 = newNode.hash;
    do {
        parent = node;
        K k2 = node.key;
        int h2 = node.hash;
        if (h1 > h2) {
            cmp = 1;
        } else if (h1 < h2) {
            cmp = -1; // 不用再比较equals，因为不会存在重复数据。
        } else if (k1 != null && k2 != null 
                && k1 instanceof Comparable
                && k1.getClass() == k2.getClass()
                && (cmp = ((Comparable)k1).compareTo(k2)) != 0) {
        } else { // 搜索也不需要，原因同上。
            cmp = System.identityHashCode(k1) - System.identityHashCode(k2);
        }
			
        if (cmp > 0) {
            node = node.right;
        } else if (cmp < 0) {
            node = node.left;
        }
    } while (node != null);

    // 看看插入到父节点的哪个位置
    newNode.parent = parent;
    if (cmp > 0) {
        parent.right = newNode;
    } else {
        parent.left = newNode;
    }
		
    // 新添加节点之后的处理
    fixAfterPut(newNode);
}
```

#### 7、equals的优化

- 我们在添加元素时，要谨防因equals的函数实现有问题，导致a.equals(b)和b.equals(a)的结果不一致。
- 所以在实现equals函数时，要遵循以下条件： ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772005335-4cf999ed-64ed-460f-813e-b29ed8e7f972.png)

### 四、TreeMap VS HashMap

- TreeMap增删改查都是O(logn)级别，而哈希表是O(1)级别。
- 当元素具备可比较性且要求升序遍历时，使用TreeMap。当对遍历没有要求时，选择HashMap。

### 五、LinkedHashMap

- 在HashMap的基础上维护元素的添加顺序，使得遍历的结果是遵循添加顺序的。
- 假设添加顺序是37，21，31，41，97，95，52，42，83![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772005661-c8dbe8ed-35f0-4f68-96a0-4964d833814c.png)

### 六、LinkedHashMap的接口实现

- 新增first和last两个属性。

```
public class LinkedHashMap<K, V> extends HashMap<K, V> {
	private LinkedNode<K, V> first;
	private LinkedNode<K, V> last;
}
```

- 给Node增加前驱和后继两个指针。

```
private static class LinkedNode<K, V> extends Node<K, V> {
    LinkedNode<K, V> prev;
    LinkedNode<K, V> next;
    public LinkedNode(K key, V value, Node<K, V> parent) {
        super(key, value, parent);
    }
}
```

- 添加一个构造节点的函数。

```
@Override
protected Node<K, V> createNode(K key, V value, Node<K, V> parent) {
    LinkedNode node = new LinkedNode(key, value, parent);
    if (first == null) { //没有头节点
        first = last = node;
    } else { //有头节点
        last.next = node;
        node.prev = last;
        last = node;
    }
    return node;
}
```

- clear函数需要清空first和last指针。

```
@Override
public void clear() {
    super.clear();
    first = null;
    last = null;
}
```

- 遍历函数

```
@Override
public void traversal(Visitor<K, V> visitor) {
    if (visitor == null) return;
    LinkedNode<K, V> node = first;
    while (node != null) {
        if (visitor.visit(node.key, node.value)) return;
        node = node.next;
    }
}
```

- 删除函数，不仅仅需要删除数据，还需要修改指针指向。
- 删除度为2的节点时，需要注意更换node与前驱/后继节点的链接位置。
- 例如，删除31![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772006336-0db3c13d-a449-45ef-ab4f-1505a85fa2cc.png)

```
@Override
protected void afterRemove(Node<K, V> willNode, Node<K, V> removedNode) {
	LinkedNode<K, V> node1 = (LinkedNode<K, V>) willNode;
	LinkedNode<K, V> node2 = (LinkedNode<K, V>) removedNode;
		
	if (node1 != node2) {
		// 交换linkedWillNode和linkedRemovedNode在链表中的位置
		// 交换prev
		LinkedNode<K, V> tmp = node1.prev;
		node1.prev = node2.prev;
		node2.prev = tmp;
		if (node1.prev == null) {
			first = node1;
		} else {
			node1.prev.next = node1;
		}
		if (node2.prev == null) {
			first = node2;
		} else {
			node2.prev.next = node2;
		}
			
		// 交换next
		tmp = node1.next;
		node1.next = node2.next;
		node2.next = tmp;
		if (node1.next == null) {
			last = node1;
		} else {
			node1.next.prev = node1;
		}
		if (node2.next == null) {
			last = node2;
		} else {
			node2.next.prev = node2;
		}
	}
		
	LinkedNode<K, V> prev = node2.prev;
	LinkedNode<K, V> next = node2.next;
	if (prev == null) {
		first = next;
	} else {
		prev.next = next;
	}
		
	if (next == null) {
		last = prev;
	} else {
		next.prev = prev;
	}
}
```

- 核心就是交换。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772007279-4c6c1ee3-b17e-4052-bdb1-ff373a1175a5.png)
- 遍历节点

```
@Override
public boolean containsValue(V value) {
    LinkedNode<K, V> node = first;
    while (node != null) {
        if (Objects.equals(value, node.value)) return true;
        node = node.next;
    }
    return false;
}
```

# 15.二叉堆（Heap）

### 一、二叉堆（Heap）

#### 1、思考

- 设计一种数据结构，用来存放整数，要求提3个接口。

- 添加元素
- 获取最大值
- 删除最大值

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772272387-772219d0-fd81-4fba-b3a7-52f0867babd7.png)

- 更优秀的数据结构：堆，获取最大值复杂度O(1)，删除最大值O(logn)，添加元素O(logn)

#### 2、概念

- 堆（Heap）也是一种树状的数据结构
- 堆的一个重要性质：任意节点的值总是大于等于或小于等于子节点的值。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772272384-8f26a0cb-c5e5-42a3-81e1-b391ff93e214.png)

- 如果任意节点的值总是大于等于子节点的值，称为最大堆，大根堆，大顶堆。
- 反之称为最小堆，小根堆，小顶堆。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772272398-dc87f806-5e35-464e-a9a6-651d851f128f.png)

- 最大堆和最小堆的最大值/最小值都在顶部。且堆中的元素必须具备可比较性。

#### 3、堆的接口设计

```
public interface Heap<E> {
    int size();	// 元素的数量
    boolean isEmpty();	// 是否为空
    void clear();	// 清空
    void add(E element);	 // 添加元素
    E get();	// 获得堆顶元素
    E remove(); // 删除堆顶元素
    E replace(E element); // 删除堆顶元素的同时插入一个新元素
}
```

### 二、二叉堆（Binary Heap）

- 二叉堆的逻辑结构就是一颗完全二叉树，所以也叫完全二叉堆。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772272412-9888ace8-f05a-40d2-99fc-131e0b873a8a.png)
- 鉴于完全二叉树的一些性质，二叉堆的底层（物理结构）一般用数组实现即可。
- 索引i的规律（n是元素数量）

- 如果i = 0，它是根节点。
- 如果i > 0，它的父节点的索引为floor((i-1) / 2)。
- 如果2i + 1 <= n - 1，它的左子节点的索引为2i + 1。
- 如果2i + 1 > n - 1，它无左子节点。
- 如果2i + 1 <= n - 1，它的右子节点的索引为2i + 2`。
- 如果2i + 1 > n - 1，它无右子节点。

### 三、二叉堆（Binary Heap）接口实现

##### 1、构造函数

```
public BinaryHeap(E[] elements, Comparator<E> comparator)  {
    super(comparator);
		
    if (elements == null || elements.length == 0) {
        this.elements = (E[]) new Object[DEFAULT_CAPACITY];
    } else {
        size = elements.length;
        int capacity = Math.max(elements.length, DEFAULT_CAPACITY);
        this.elements = (E[]) new Object[capacity];
        for (int i = 0; i < elements.length; i++) {
            this.elements[i] = elements[i];
        }
    heapify();
    }	
}
```

##### 2、添加

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772272456-99dc12bc-e33a-4d15-9c85-459d441fda71.png)

- 添加操作需要循环执行以下步骤：

- 如果node > 父节点，则与父节点交换位置。
- 如果node <= 父节点，或者node没有父节点，则退出循环。

- 这个过程叫做上滤（Sift Up），时间复杂度为O(logn) 。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772275152-4d2297fc-a8fa-4906-aa97-2cfe1caff441.png)

```
@Override
public void add(E element) {
    elementNotNullCheck(element); //非空判断
    ensureCapacity(size + 1); //扩容代码
    elements[size++] = element;
    siftUp(size - 1);
}

//非空判断
private void elementNotNullCheck(E element) {
    if (element == null) {
        throw new IllegalArgumentException("element must not be null");
    }
}

// 扩容
private void ensureCapacity(int capacity) {
    int oldCapacity = elements.length;
    if (oldCapacity >= capacity) return;
		
    // 新容量为旧容量的1.5倍
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    E[] newElements = (E[]) new Object[newCapacity];
    for (int i = 0; i < size; i++) {
        newElements[i] = elements[i];
    }
    elements = newElements;
}

//上滤
/**
 * 让index位置的元素上滤
 * @param index
 */
private void siftUp(int index) {
    E element = elements[index]; //先备份一份节点的值
    while (index > 0) {
        int parentIndex = (index - 1) >> 1; //获取父节点索引
        E parent = elements[parentIndex]; //获取父节点的内容
        if (compare(element, parent) <= 0) break;
			
        // 将父元素存储在index位置
        elements[index] = parent;
			
        // 重新赋值index
        index = parentIndex;
    }
    elements[index] = element; //当最终确认交换位置后，再将备份的值赋给新的位置。
}
```

##### 3、删除

- 用最后一个节点覆盖根节点
- 删除最后一个节点
- 循环执行以下步骤（43简称为node）

- 如果node < 最大的子节点，与最大的子节点交换位置。
- 如果node >= 最大的子节点，或者node没有子节点，则退出循环。

- 这个过程叫做下滤（Sift Down），时间复杂度：O(logn)。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772275272-1ed9303e-8d85-4262-ba64-f100352d926f.png)

- 同样的，交换位置的操作可以像添加那样进行优化。

```
@Override
public E remove() {
    emptyCheck();
		
    int lastIndex = --size; //最后一个元素的索引
    E root = elements[0]; //拿出0位置的元素
    elements[0] = elements[lastIndex];
    elements[lastIndex] = null;
		
    siftDown(0); //下滤
    return root;
}

/**
 * 让index位置的元素下滤
 * @param index
 */
private void siftDown(int index) {
    E element = elements[index];
    int half = size >> 1;
    // 第一个叶子节点的索引 == 非叶子节点的数量
    // index < 第一个叶子节点的索引
    // 必须保证index位置是非叶子节点
    while (index < half) { 
        // index的节点有2种情况
        // 1.只有左子节点
        // 2.同时有左右子节点
			
        // 默认为左子节点跟它进行比较
        int childIndex = (index << 1) + 1;
        E child = elements[childIndex];
			
        // 右子节点
        int rightIndex = childIndex + 1;
			
        // 选出左右子节点最大的那个
        if (rightIndex < size && compare(elements[rightIndex], child) > 0) {
            child = elements[childIndex = rightIndex];
        }
			
        if (compare(element, child) >= 0) break;

        // 将子节点存放到index位置
        elements[index] = child;
        // 重新设置index
        index = childIndex;
    }
    elements[index] = element;
}
```

##### 4、replace操作

- 删除堆顶元素，并用新值替换。
- 用新值替换堆顶，然后做下滤操作即可。

```
@Override
public E replace(E element) {
    elementNotNullCheck(element);
		
    E root = null;
    if (size == 0) {
        elements[0] = element;
        size++;
    } else {
        root = elements[0]; //保存要删除的元素
        elements[0] = element; //替换堆顶元素
        siftDown(0); // 下滤
    }
    return root;
}
```

##### 5、批量建堆

- 批量建堆有两种做法

- 自上而下的上滤
- 自下而上的下滤

- 自上而下的上滤：从上而下拿到每个元素，然后上滤。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772275741-412978c3-4290-4708-bdff-56df44f1550a.png)
- 自下而上的下滤：从下而上拿到每个元素，然后下滤。

- 叶子节点无须下滤，所以从第一个非叶子节点开始操作。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772276956-8af2a2b6-3c4d-4f57-a953-b2e6257b9cc5.png)

- 效率比较： ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772277110-cc58ab51-703e-4e11-8cda-116fbb693155.png)
- 下滤执行最长操作的元素最少，而上滤需要执行最长操作的元素非常多。所以下滤效率更高。

### 四、leetcode算法题

[最小K个数](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsmallest-k-lcci%2F)

# 16.优先级队列

### 一、优先级队列（Priority Queue）

- 普通的队列是先进先出原则。
- 优先级队列是按照优先级高低进行出队，比如将优先级最高的元素作为队头优先出队。
- 使用场景：

- 医院急诊根据病人病情和挂号时间决定谁先看病。
- 操作系统的多任务调度，队列元素是任务，优先级是任务类型。

### 二、优先级队列（Priority Queue）底层实现

- 通过最大堆来实现优先级队列。

```
public class PriorityQueue<E> {
    private BinaryHeap<E> heap; // 二叉堆
	
    public PriorityQueue(Comparator<E> comparator) {
        heap = new BinaryHeap<>(comparator);
    }
	
    public PriorityQueue() {
        this(null);
    }
	
    public int size() {
        return heap.size();
    }

    public boolean isEmpty() {
        return heap.isEmpty();
    }
	
    public void clear() {
        heap.clear();
    }

    public void enQueue(E element) {
        heap.add(element); //入队
    }

    public E deQueue() {
        return heap.remove(); //让优先级最高的元素出队
    }

    public E front() {
        return heap.get(); //获取堆顶元素
    }
}
```

# 17.哈夫曼编码

### 一、哈夫曼编码

- 哈夫曼编码，它是现代压缩算法的基础。
- 假设把字符串"ABBBCCCCCCDDDDDDEE"转成二进制编码进行传输。

- 可以转成ASCII编码（65-69，1000001 - 1000101），但是有点冗长，如果希望编码更短呢？
- 可以先约定5个字母对应的二进制 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772501129-451aa547-b7d3-4fe5-8491-55f6ba5642cf.png)
- 如果使用哈夫曼编码，可以压缩至41个二进制位，约为原来长度的68.3%

### 二、哈夫曼树

- 先计算出每个字母的出现频率（权值，这里直接用出现次数）。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772500942-73eb848f-3611-4d69-a064-601f788b6b63.png)![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772500907-cc1bada1-13d3-4f27-894e-c0a349119697.png)
- 利用这些权值，构建一颗哈夫曼树。

### 三、构建哈夫曼树（假设有n个权值）

- 以权值作为根节点构建n棵二叉树，组成森林。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772500951-15125615-aa6f-436d-9862-95aef2053e8f.png)
- 在森林中选出2个根节点最小的树合并，作为一颗新树的左右子树，且新树的根节点为其左右子树根节点之和。
- 从森林中删除刚才选取的2棵树，并将新树加入森林。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772500920-ba4fbca6-3117-4612-8c44-ac6c6b82c6d8.png)
- 重复2，3步骤，直到森林只剩一棵树为止，该树即为哈夫曼树。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772502135-91316afa-50c1-4554-8e03-b4a37b9de1c2.png)![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772502194-7811be73-fcda-40ee-beaf-e63f0399f46e.png)

### 四、构建哈夫曼编码

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772502323-592e53eb-b8e0-4388-981c-c53228b08fd9.png)

# 18.Trie

### 一、概念

- Trie 也叫做字典树、前缀树(Prefix Tree)、单词查找树。
- Trie 搜索字符串的效率主要跟字符串的长度有关。
- 假设使用 Trie 存储 cat、dog、doggy、does、cast、add 六个单词。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772550963-31c0b3a5-ed81-430e-b113-e327074ee64c.png)
- 假设要查找dog，首先在根节点搜索有没有d子节点，然后再查看d节点下是否有o子节点，最后在o节点下查看是否有g子节点。

### 二、接口设计

- 可以通过set或字典来实现一个Trie。 ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1668772550985-51a88e06-ad8f-486c-bd5e-4bc30f683d98.png)

### 三、接口实现

#### 1、Node接口

```
private static class Node<V> {
    Node<V> parent;
    HashMap<Character, Node<V>> children; //子节点
    Character character;
    V value;
    boolean word; // 是否为单词的结尾（是否为一个完整的单词），即上面的红色节点。
    public Node(Node<V> parent) {
        this.parent = parent;
    }
}
```

#### 2、查找

```
private Node<V> node(String key) {
    keyCheck(key);
		
    Node<V> node = root;
    int len = key.length();
    for (int i = 0; i < len; i++) {
        if (node == null || node.children == null || node.children.isEmpty()) return null;
        char c = key.charAt(i); 
        node = node.children.get(c);
    }
    return node;
}
```

未完待续...