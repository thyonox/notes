# 语言基础

## 语言概述
### 语言历史
- **1991年**，Sun Microsystems公司的工程师James Gosling和他的团队开发了一种名为“Oak”的语言，这是Java的前身。
- **1995年**，Java1.0发布，这是Java的第一个公开版本，具有“Write Once，Run Anywhere”的特性，这在当时非常高级，Java代码具有了广泛的可移植性，受到了开发者们的广泛关注。
- **2000年**，Java 2 Platform, Enterprise Edition (J2EE)发布，为企业级应用开发提供了一个标准平台，J2EE包括了Servlet、JSP、EJB等组件。
- **2006年**，Sun Microsystems宣布Java成为开源项目，Java开发工具包（JDK）在GNU通用公共许可证下发布，由此产生了后来的OpenJDK。
- **2009年**，Oracle公司收购了Sun Microsystems，成为Java的新主人。
- **2013年**，Java 8发布，引入了Lambda表达式、Stream API、默认方法等重要特性，大幅提升了编程的简洁性和功能性，成为了使用最广泛的Java版本。
- **2019年至今**，Java进入了快速发布周期，每六个月发布一个新版本，持续引入新特性和改进，如增强的垃圾回收器、性能优化、新的API等。
### 语言特性
- **面向对象**  
    Java是一种完全面向对象的编程语言，支持封装、继承和多态。类和对象是Java程序的核心，提供了模块化和代码复用的能力。
- **平台无关性**  
    Java通过Java虚拟机（JVM）实现“一次编写，到处运行”（Write Once, Run Anywhere）。Java代码编译为字节码，可以在任何支持JVM的平台上运行，不依赖于特定硬件或操作系统。
- **简单性**  
    Java语法简洁，借鉴了C和C++的优点，但去掉了复杂特性（如指针、头文件、多重继承）。自动垃圾回收机制也简化了内存管理。
- **健壮性**  
    Java通过强类型检查、异常处理机制和运行时检查减少程序错误。自动垃圾回收避免了内存泄漏，数组边界检查防止越界访问。
- **安全性**  
    Java内置了多层次的安全机制，包括字节码验证、沙箱模型和安全管理器，适合开发网络应用和防止恶意代码。
- **多线程支持**  
    Java提供了内置的多线程机制，开发者可以轻松创建并发程序，适用于高性能、多任务应用。
- **高性能**  
    虽然Java基于虚拟机运行，性能略低于C++，但通过即时编译（JIT Compiler）和优化，Java性能已接近原生代码，适合企业级应用。
- **分布式支持**  
    Java提供了对网络编程的强大支持（如RMI、Socket、HTTP等），非常适合开发分布式系统和Web应用。
- **动态性**  
    Java支持动态加载类、反射机制和运行时类型识别，适合构建灵活、可扩展的系统。
- **丰富的API和生态系统**  
    Java提供庞大的标准库（Java API），涵盖网络、文件操作、GUI、数据库访问等功能。此外，Java生态系统拥有丰富的开源框架和工具（如Spring、Hibernate）。
- **向后兼容性**  
    Java注重向后兼容，新版本通常能运行旧版本的代码，保护开发者的投资。
- **国际化支持**  
    Java内置了对Unicode的支持，便于开发多语言应用，适合全球化的软件需求。
### 基本规则
- **命名规则**
	- 类和接口命名：
		- 必须以字母（`A-Z`或`a-z`）、下划线（`_`）或美元符号（`$`）开头。
		- 通常采用大驼峰命名法（CamelCase），即首字母大写，每个单词的首字母大写，如 `MyClassName`。
		- 名称应具有描述性，避免使用无意义的单字母或缩写。
	- 方法命名：
		- 必须以字母、下划线或美元符号开头。
		- 采用小驼峰命名法，即首字母小写，后续单词首字母大写，如 `calculateTotalPrice`。
		- 通常使用动词或动词短语，反映方法的功能。
	- 变量命名：
		- 规则同方法命名，采用小驼峰命名法，如 `userName`。
		- 应避免使用无意义的名称，需具有语义，如 `count` 而不是 `x`。
	- 常量命名：
		- 全部大写，单词间用下划线分隔，如 `MAX_VALUE`。
		- 通常用于 `static final` 修饰的常量。
	- 包命名：
		- 全小写，通常使用反向域名结构，如 `com.example.project`。
		- 避免使用下划线或特殊字符。
	- 关键字限制：
		- 不能使用Java的保留关键字（如 `class`, `int`, `public` 等）作为标识符。
		- 区分大小写，`Class` 和 `class` 是不同的。
	- 合法字符：
		- 标识符可以包含字母、数字、下划线和美元符号，但数字不能作为开头。
		- 支持Unicode字符，但不推荐使用非ASCII字符以确保可读性。
- **注释规则**
	- 注释类型：
		- 单行注释：以 `//` 开头，适用于简短说明，注释内容直到行尾有效。
		- 多行注释：以 `/*` 开头，以 `*/` 结束，适用于多行说明。
		- 文档注释（Javadoc）：以 `/**` 开头，以 `*/` 结束，用于生成API文档，常用于类、方法和字段的说明，包含特定标签（如 `@param`, `@return`）。
	- 注释规范：
		- 注释内容不影响程序执行，编译器会忽略。
		- 注释不能嵌套（如 `/* /* */ */` 是非法的）。
		- 文档注释应遵循Javadoc规范，清晰描述功能、参数、返回值等。
		- 注释应简洁、准确，避免冗余或误导性描述。
- **结构规则**
	- 文件名：
		- Java源文件必须以 `.java` 扩展名保存。
		- 文件名必须与文件中定义的 `public` 类或接口名完全一致（包括大小写）。
		- 一个源文件中最多只能有一个 `public` 类。
	- 包声明：
		- 如果使用包，`package` 语句必须是文件的第一行非注释语句。
		- 包名应与目录结构一致。
	- 导入语句：
		- `import` 语句用于引入其他包中的类，位于 `package` 语句之后，类定义之前。
		- 避免导入未使用的类，以保持代码简洁。
- **编码规则**
	- 大小写敏感：
		- Java严格区分大小写，如 String 和 string 不同。
	- 代码块界定：
		- 使用大括号 `{}` 定义代码块，类、方法、语句块等都必须遵循。
	- 编码格式：
		- 推荐使用UTF-8编码保存源文件，确保国际化支持。
	- 缩进和格式：
		- 虽然缩进不影响语法，但必须遵循一致的缩进风格（如4个空格或1个Tab）以提高可读性。
		- 每行代码建议不超过80-120个字符，必要时换行。
- **其它规则**
	- 主类和入口点：
		- 如果程序需要独立运行，必须包含一个 `public static void main(String[] args)` 方法作为程序入口。
	- 访问控制：
		- 必须使用访问修饰符（如 `public`, `private`, `protected`）或默认访问级别来定义类、方法、变量的可见性。
	- 分号结束：
		- 每条语句必须以分号 `;` 结束（除非是代码块或特定结构）。
	- 类和对象的依赖：
		- Java是面向对象的语言，代码必须定义在类中（不能直接在文件顶级写执行代码）。
	- 异常处理：
		- 对于检查型异常（Checked Exception），必须通过 `try-catch` 或 `throws` 处理，否则编译错误。





## 数据类型
### 基本数据类型
- **整数类型**
	- **byte**：
		- 大小：1 字节（8 位）
		- 范围：-128 到 127（-2^7 到 2^7 - 1）
		- 默认值：0
		- 用途：适合存储小范围整数，节省内存，如小型计数器。
		- 示例：`byte b = 100`;
	- **short**：
		- 大小：2 字节（16 位）
		- 范围：-32,768 到 32,767（-2^15 到 2^15 - 1）
		- 默认值：0
		- 用途：用于中等范围的整数，较少使用，但在某些需要节省内存的场景（如嵌入式系统）有用。
		- 示例：`short s = 10000`;
	- **int**：
		- 大小：4 字节（32 位）
		- 范围：-2,147,483,648 到 2,147,483,647（-2^31 到 2^31 - 1）
		- 默认值：0
		- 用途：最常用的整数类型，适用于大多数计数、索引等场景。
		- 示例：`int i = 123456`;
	- **long**：
		- 大小：8 字节（64 位）
		- 范围：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807（-2^63 到 2^63 - 1）
		- 默认值：0L
		- 用途：用于大范围整数，如时间戳（毫秒）、大文件大小。
		- 备注：字面量需加 `L` 或 `l` 后缀，如 `long l = 1234567890L`;
- **浮点类型**
	- **float**：
		- 大小：4 字节（32 位）
		- 精度：约 6-7 位有效数字
		- 范围：约 ±3.4E38（IEEE 754 标准）
		- 默认值：0.0f
		- 用途：适合需要节省内存的浮点计算，但精度较低。
		- 备注：字面量需加 `F` 或 `f` 后缀，如 `float f = 3.14f`;
	- **double**：
		- 大小：8 字节（64 位）
		- 精度：约 15-16 位有效数字
		- 范围：约 ±1.7E308（IEEE 754 标准）
		- 默认值：0.0
		- 用途：默认的浮点类型，适用于大多数科学计算、图形处理等。
		- 示例：`double d = 3.14159`;
		- 注意：浮点运算可能存在精度误差（如 `0.1 + 0.2 != 0.3`），需谨慎处理。
- **字符类型**
	- **char**：
		- 大小：2 字节（16 位）
		- 范围：0 到 65,535（Unicode 字符， 到 \uFFFF）
		- 默认值：''（空字符）
		- 用途：表示单个 Unicode 字符，如字母、数字、符号等。
		- 备注：
			- 使用单引号定义，如 `char c = 'A';` 或 `char c = '\u0041';`
			- 可以存储整数（0-65535），但通常表示字符。
		- 示例：`char c = '中';`（支持中文等 Unicode 字符）
- **布尔类型**
	- **boolean**：
		- 大小：理论上 1 位（实际由 JVM 实现决定，可能占用 1 字节或更多）
		- 取值：`true` 或 `false`
		- 默认值：`false`
		- 用途：用于逻辑判断、条件控制等。
		- 示例：`boolean isActive = true;`
		- 注意：不能直接用 0 或 1 表示布尔值（与 C/C++ 不同）。




### 引用数据类型





## 访问修饰符





# Java概述

## Java语言发展史



## Java语言跨平台原理

Java语言一个重要的特性就是“一次编写，到处运行”，这实现了代码的跨平台和可移植性。这个特性是基于Java虚拟机（JVM）来实现的。

当Java编译器（javac）将Java源代码（.java）编译为字节码（.class）文件后，由Java虚拟机来对字节码文件解释执行转换为机器码。如此只需要安装不同操作系统对应的Java虚拟机，保证相同的字节码文件在不同操作系统的Java虚拟机上解释出来的机器码实现的功能一致，就可以实现跨平台特性。

![[基础语法--1.png]]

在字节码转为机器码这一过程中，JVM最初是通过解释器逐条解释执行字节码。释器读取字节码指令并将其逐条转换为相应的机器指令。这种方式简单但效率较低。为了提高效率，后来引入了**即时编译器**（Just-In-Time Compilation, JIT），它在程序运行时将热点代码（经常执行的代码）编译为本地机器码。使其在后续执行时能够直接运行在机器上，而不需要再通过解释器逐条解释执行。

还有一种优化技术被称为**提前编译器**（Ahead-of-Time Compilation,AOT），它是一种直接将高级语言编译为机器码的技术。AOT在程序运行前，就将字节码文件编译为机器码，避免了运行时的编译过程、JIT预热等方面的开销，加快启动时间，减少内存占用（由于不需要 JIT 编译器和运行时编译缓存，对于嵌入式设备尤其有用），并且由于AOT编译的机器码是确定的，在部署前就已经生成，所以更能预测程序的运行表现，而JIT编译器可能根据运行时的不同情况优化代码，因此性能表现可能有所波动。在JDK9中Oracle引入了实验性质的AOT编译器`jaotc` ，但在后续版本中并没有得到扩展或推广，而是专注于增强和优化即时编译（JIT）技术以及其他 JVM 性能提升方面的工作。主要原因在于如果使用AOT编译器，就不能使用一些动态特性，如反射、动态代理，并且因为无法获取运行时情况，也就不能进行动态优化。如果存在AOT的使用需求，可以使用**GraalVM**和OpenJDK。

经常说**Java语言编译与解释共存**，因为一方面Java需要先编译再解释执行，另一方面在字节码到机器码这一过程中也存在传统的逐行解释和提供效率的即时编译。所以Java并不是传统意义上的解释性语言，它平衡了编译型语言的执行性能和解释型语言的跨平台特性：

可能认为Java语言比传统解释型语言需要多一次编译成字节码的过程，是不是比传统解释型语言更慢，其实恰恰相反，Java通过编译优化、即时编译、编译成字节码避免逐行解释时解析的开销和类型检查、字节码的高效执行、优化的运行环境等手段，使得Java在大多数情况下比纯解释型语言更快。

## JVM、JRE、JDK

- JVM（Java Virtual Machine）：Java虚拟机，运行Java字节码的虚拟机，是Java运行环境的核心，提供了跨平台执行的能力
- JRE（Java Runtime Environment）：Java运行环境，是Java程序运行时所需要的环境，提供了运行Java程序所需要的所有组件，包括JVM及核心类库和其他支持文件。
- JDK（Java Development Kit）：Java开发工具包，开发Java程序所需要的完整环境，包括JRE和开发Java程序的工具和API。OracleJDK就比OpenJDK多了诸如监测Java程序运行的工具。

![[基础语法--2.png]]

## JDK版本选择

对于JDK的选择，主要有以下几方面的考虑：

1. Oracle自从JDK11开始采取的订阅付费策略，对于企业和生产环境的商业用途需要付费订阅。
2. JDK采取向下兼容，最新的长期支持版本无疑是最好的选择，拥有更多的新特性，但要考虑到项目可能会依赖特定版本。
3. JDK11之后如果不使用Oracle JDK，应该选择哪个第三方OpenJDK版本？项目是否依赖Oracle JDK的商业功能和工具？

如果是在企业中，肯定需要选择当前项目中使用的JDK版本。但对于个人学习使用，建议使用最新的JDK长期支持版本，并且明白各个版本增加的新特性。

OpenJDK项目本身在https://openjdk.org/上进行管理，在其中可以找到规范、源代码和邮件列表，想要使用需要选择一个发行版。

OpenJDK具有非常多的发行版，如：Oracle OpenJDK、Adoptium Eclipse Temurin、Azul Zulu、IBM Semeru Runtime等等，建议使用Adoptium Eclipse Temurin的发行版。

[https://www.ga0x.com/docs/Java/base/whichjdk#adoptium-eclipse-temurin](https://www.ga0x.com/docs/Java/base/whichjdk#adoptium-eclipse-temurin)

## 安装JDK

如下载安装OracleJDK，需要到[Oracle官网](https://www.oracle.com/java/technologies/downloads/#jdk21-windows)下载，建议下载压缩版，手动添加到Path目录。

![[基础语法--3.png]]

如下载安装OpenJDK，需要到[Adoptium](https://adoptium.net/temurin/releases/?os=windows&package=jdk&arch=x64)官网下载，建议下载压缩版，手动添加到Path目录。

![[基础语法--4.png]]

在安装JDK时，如果不是安装版，并且勾选了添加到环境变量，则需要手动添加到环境变量，这样做的目的是为了**让系统快速找到JDK提供的工具**，如编译器`javac`，做法是将JDK的`bin`目录添加到`path`环境变量中。但是如果是在Idea这样的集成开发环境（IDE）构建项目时，可以直接在IDE中指定JDK的位置，IDE会在内部管理和使用这个JDK，所以不需要添加到环境变量做全局配置。当然当项目开发完毕后进行部署时，在测试和生产环境中需要和开发环境保持一致。

如果存在多个JDK版本，同时又有添加到环境变量的需要，可以进行下面操作：

1. 打开环境变量：设置-系统-高级系统设置-环境变量
2. 如果之前安装过JDK，在`path`中会有残留，先删除。
3. 添加自定义环境变量，如JDK11，路径设置为bin目录的上一级。至于是用户变量还是系统变量，现在都是个人PC，直接添加到系统变量就完事了。
4. 添加`JAVA_HOME`环境变量，这个变量是指定当前活动 JDK 的标准环境变量，变量值通过`% %`引用JDK11这个变量名。
5. 将`JAVA_HOME`这个环境变量添加到`path`中。
6. 如果需要更换JDK版本只需要将`JAVA_HOME`的值引用其他JDK的变量名即可。

![[基础语法--5.png]]

![[基础语法--6.png]]

**❗注意：如果设置系统变量，则检查的命令行工具需要使用管理员权限。若不使用管理员权限则不生效，则需要重启刷新会话。**

## JDK目录

JDK 的目录结构可能会因为版本和发行版的不同而略有差异，但一般包括以下主要目录和文件：

1. bin 目录
    - 内容：包含 JDK 提供的可执行文件和工具，如 `java`、`javac`、`javadoc`、`jar` 等。
    - 作用：用于编译、运行和调试 Java 程序。例如，`javac` 用于编译 Java 源代码，`java` 用于运行 Java 应用程序。
2. conf 目录（从 JDK 9 开始引入）
    - 内容：包含 JDK 配置文件，如 `net.properties`、`security` 文件夹等。
    - 作用：提供可配置的设置以影响 JVM 的行为和网络等方面的配置。
3. include 目录
    - 内容：包含 C/C++ 头文件，用于使用 JNI（Java Native Interface）编写本地方法。
    - 作用：帮助开发者在 Java 应用程序中调用本地代码。
4. jmods 目录（从 JDK 9 开始引入）
    - 内容：包含 JDK 的标准模块，以 `.jmod` 文件的形式提供。
    - 作用：用于模块化 Java 平台，使得 JDK 和应用程序可以模块化部署。
5. legal 目录
    - 内容：包含 JDK 中各组件的法律信息和许可证文件。
    - 作用：提供法律声明和使用许可信息。
6. lib 目录
    - 内容：包含 Java 类库和资源文件，如 `tools.jar`、`dt.jar` 等。
    - 作用：提供 Java 运行时所需的类库和工具。
7. jre 目录（JDK 8 及之前的版本）
    - 内容：包含一个完整的 Java 运行环境，包括 `bin`、`lib`、`conf` 等子目录。
    - 作用：提供运行 Java 应用程序所需的环境。在 JDK 9 及以后，JRE 被整合到 JDK 中，不再单独提供。
8. src.zip 文件
    - 内容：包含 JDK 提供的核心类库的源代码。
    - 作用：提供开发者参考，了解 Java 标准库的实现细节。

**其他可能存在的目录：**

- sample 目录
    - 内容：包含示例代码和演示程序。
    - 作用：用于展示 JDK 功能和帮助开发者学习。
- man 目录
    - 内容：包含 JDK 工具的手册页（在 Unix-like 系统中常见）。
    - 作用：提供命令行工具的使用说明。
- lib/security 目录
    - 内容：包含安全策略文件和证书库。
    - 作用：管理 Java 平台的安全设置，如 `cacerts`（受信任的证书颁发机构列表）。

# Hello World

1. 编写源码
    
    创建保存下面文件，后缀名改为`.java` 。
    
    ```java
    public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello World");
        }
    }
    ```
    
2. 编译成字节码
    
    使用`javac`工具进行编译，会生成`HelloWorld.class`文件。
    
    ```java
	javac HelloWorld.java
    ```
    
3. 运行
    
    使用`java`工具运行，不需要`.class`后缀。
    
    ```java
    java HelloWorld
    ```
    

# 基础语法

## 注释

注释用于帮助开发者理解和维护代码，会被编译器忽略，不会出现在字节码文件中。文档注释可以通过`javadoc`工具生成HTML格式的文档。

1. 单行注释：`//`
2. 多行注释：`/*...*/`
3. 文档注释：`/**…*/`

使用`javadoc`工具生成HTML格式的文档注释时：

```powershell
javadoc [options] [packagenames] [sourcefiles] [@files]
```

示例：

```powershell
javadoc -d docs -sourcepath src com.example
```

说明：

- `-d docs`：指定生成的文档输出到 `docs` 目录。
- `-sourcepath src`：指定源代码的根目录为 `src`。
- `com.example`：指定需要生成文档的包名或类名。

常用选项：

- `-d <directory>`：指定生成文档的输出目录。
- `-sourcepath <path>`：指定源代码的根目录。
- `-classpath <path>`：指定类路径。
- `-subpackages <package>`：生成指定包及其子包的文档。
- `-author`：包括 `@author` 标签的信息。
- `-version`：包括 `@version` 标签的信息。

或者使用Idea生成文档：工具-生成javadoc。

## 标识符

> 标识符是用于命名变量、方法、类、接口、包等程序元素的名称。

**标识符规则：**

- 标识符必须由字母、数字、下划线或美元符号组成。
- 标识符不能以数字开头。必须以字母、下划线或美元符号开始。
- Java 标识符是区分大小写的。
- 标识符不能使用 Java 的保留字和关键字。
- Java 标识符可以包含 Unicode 字符，这意味着标识符可以包含各种语言的字符。

**命名约定：**

- 变量名、方法名使用小驼峰命名法（从第二个单词开始每个单词的首字母大写）。
- 类名使用大驼峰命名法（每个单词的首字母都大写）。
- 见名知意。

## 转义字符
//todo

## 关键字

关键字是被赋予特殊含义的标识符，并且不能用做变量名、类名、方法名等，保留字是为了应对后续的更新，当前没有特殊含义，但不能使用。

| 访问控制       | private             | protected                        | public                       |                            |                               |                          |                  |
| ---------- | ------------------- | -------------------------------- | ---------------------------- | -------------------------- | ----------------------------- | ------------------------ | ---------------- |
| 类，方法和变量修饰符 | abstract            | class                            | extends                      | final                      | implements                    | interface                | native           |
| 程序控制       | new<br>break<br>for | static<br>continue<br>instanceof | strictfp<br>return<br>switch | synchronized<br>do<br>case | transient<br>while<br>default | volatile<br>if<br>assert | enum<br>else<br> |
| 错误处理       | try                 | catch                            | throw                        | throws                     | finally                       |                          |                  |
| 包相关        | import              | package                          |                              |                            |                               |                          |                  |
| 基本类型       | boolean<br>short    | byte                             | char                         | double                     | float                         | int                      | long             |
| 变量引用       | super               | this                             | void                         |                            |                               |                          |                  |
| 保留字        | goto                | const                            |                              |                            |                               |                          |                  |

## 数据类型

> java中数据类型分为**基本数据类型**和**引用数据类型**。

### 基本数据类型

| 数据类 型 | 关键字        | 位数  | 字节  | 取值范围                                                               |
| ----- | ---------- | --- | --- | ------------------------------------------------------------------ |
| 整数类型  | byte       | 8   | 1   | -128~127                                                           |
|       | short      | 16  | 2   | -32768~32767                                                       |
|       | int(默认)    | 32  | 4   | -2的31次方到2的31次方-1                                                   |
|       | long       | 64  | 8   | -2的63次方到2的63次方-1                                                   |
| 浮点类型  | float      | 32  | 4   | 负数：-3.402823E+38到-1.401298E-45 正数： 1.401298E-45到3.402823E+38       |
|       | double(默认) | 64  | 8   | 负数：-1.797693E+308到-4.9000000E-324 正数：4.9000000E-324 到1.797693E+308 |
| 字符类型  | char       | 16  | 2   | 0-65535                                                            |
| 布尔类型  | boolean    | 8   | 1   | true，false                                                         |

Bit（比特/位）是信息的最小单位，表示0或1，通常用小写b表示。

Byte（字节）是数据的基本单位，由8个Bit组成，表示256个值（正数127个、负数128个、零1个），通常用大写B表示。

1B=8bit；1KB=1024B；1MB=1024KB；1GB=1024MB；1TB=1024GB

其中byte、short、int、long的取值范围解释：

二进制中，最高位表示符号位（0表示正数，1表示负数），其余位数表示数值。

最大值是$01111111_2=1_2^0+1_2^1+...1*2^6=127_{10}$

最小值是$10000000_2=-128_{10}$

‘a’ – 97 a-z是连续的，所以’b’对应的数值是98，‘c’是99，依次递加 ’A’ – 65 A-Z是连续的，所以’B’对应的数值是66，‘C’是67，依次递加 ’0’ – 48 0-9是连续的，所以’1’对应的数值是49，’2’是50，依次递加

这个最小值是一个特殊值，如果按最高位为符号位来看，它应该表示“负零”，但计算机运算中没有“负零”这一概念，而是将这一值作为了最小边界。无法通过十进制的-128计算出二进制的-128，这是一个特殊值。可以通过补码表示法，在127的基础上每位取反加1得到-127，然后再减1（右移）计算出。

char数据类型没有负值，是因为char类型设计初衷就是为了表示Unicode字符，这些字符对应的十进制是没有负值的。char类型本质上是一个无符号的16位整数：

最小值：$0000000000000000_2=0_{10}$

最大值：$1111111111111111_2=2^{15}+2^{14}+...+2^0=2^{16}-1=65535_{10}$

至于float和double类型，因为表示有小数部分，所以分为三部分：符号位、指数位、尾数位。

TODO

### 引用数据类型

TODO

## 变量
---
### 变量本质
---
变量本质上是内存中的一个存储位置（地址），计算机内存由许多存储单元组成，每个单元都有一个唯一的地址，变量名是该地址的符号表示，这样就可以通过变量名来访问和操作存储在该地址中的数据，而不需要直接使用内存地址。对于基本数据类型，地址在栈内存中，变量存储的就是其值，而对于引用数据类型（类、接口、数组、枚举等），地址在堆内存中，变量存储的是对象的引用（内存地址），而不是对象本身。

### 变量声明
---
- 因为 Java 是强类型语言，所以在变量声明时必须确定其类型：

	```java
	int age;
	double salary;
	```

也可以在声明的同时进行赋值：
 ```
```java
int age = 25,hz = 144;
double salary = 55000.75;
```

### 变量作用域
---
Java 变量有三种作用域，同一作用域中中，变量名不能重复。
1. **局部变量**
    在方法、构造函数或块中声明的变量，只在其声明的范围内有效。不能被访问修饰符和`static`所修饰，能被`final`所修饰。存储在栈内存中。不会自动赋予默认值。
2. **实例变量**
    在类中声明，但在方法、构造函数或块之外，属于对象。能被访问修饰符和`static`所修饰，能被`final`所修饰。存储在堆内存中。会在链接阶段被自动赋予默认值。
3. **类变量（静态变量）**
    使用 `static` 关键字声明，属于类而不是实例。会被所有实例共享，存储在方法区。会在链接阶段被自动赋予默认值。

在初始化`long`和`float`类型的变量时，需要在字面量后面加`L`和`F` 。这是因为整数类型和浮点数类型的默认值是`int`和`double` ，虽然已经注明了数据类型，但为了简化语言设计、提高性能等方面的考虑，编译器会将整数和浮点数隐式转换为`int`类型和`double`类型，在数值超出默认类型范围或精度不足时。强制要求后缀可以在编译时捕获这些错误，防止运行时问题。

### 常量

常量是一个固定值，在程序运行期间不会改变，也就是常量代表的内存地址的值不会改变。**Java 使用 `final` 关键字来声明常量**。对于基本数据类型常量，值本身不可变，对于引用类型常量，引用不可变，**但属性是否可变，需要看属性本身是否也被定义为 `final`**。

```java
final int MAX_VALUE = 100;
final double PI = 3.14159;
```

**常量的特点：**
1. 常量在声明时就需要初始化。
2. 一旦初始化后，值（内存地址）不能再改变。
3. 常量通常使用大写字母表示，多个单词之间用下划线连接。

**常量的意义：**
1. 提高代码可读性，避免魔法数字（Magic Numbers）。
2. 方便维护和修改。
3. 提高程序性能，编译器可以对常量进行优化，提高程序可靠性。

## 类型转换
---
### 基本数据类型转换
---
就如在声明 long 和 float 类型的变量时，需要在字面量后面加`L`和`F`，是为了避免隐式的类型转换。在 Java 中存在类型转换，类型转换是指在不同数据类型之间进行转换的过程。基本数据类型转换分为两种：
1. **隐式类型转换（自动类型转换/扩宽转换）**
    是指编译器自动进行的类型转换，这种转换通常在没有数据丢失风险情况下进行，发生在小范围类型转为大范围类型时。
    ```java
    int a = 10;
    double b = a; // int 自动转换为 double
    ```
    基本类型的隐式转换规则：
	![[基础语法--8.png]]
2. **显式类型转换（强制类型转换/缩窄转换）**
    是指明确指示编译器进行的类型转换，这种转换通常在有数据丢失风险和精度降低情况下进行，发生在大范围类型转为小范围类型时。
    ```java
    double d = 9.78;
    int i = (int) d; // 强制转换 double 为 int，结果为 9，精度丢失
    ```

### 引用数据类型转换
---
引用类型的转换主要涉及到类的继承和接口的实现，分为两种：
1. **向上转型**
    是指子类对象转换为父类对象。
    ```java
    class Animal {}
    class Dog extends Animal {}
    
    Animal animal = new Dog(); // 向上转型，子类对象自动转换为父类对象
    ```
2. **向下转型**
    是指父类对象转换为子类对象。
    ```java
    class Animal {}
    class Dog extends Animal {}
    
    Animal animal = new Dog(); // 向上转型
    if (animal instanceof Dog) {
        Dog dog = (Dog) animal; // 向下转型，强制转换
    }
    ```
    
    `instanceof` 操作符用于检查一个对象是否是某个类或其子类的实例。向下转型时，如果父类引用指向的对象并不是目标子类类型，直接进行类型转换会导致类转换异常(`ClassCastException`)使用`instanceof` 操作符在转换前进行检查就可以避免这种异常。尤其在接口编程（多态场景）中，有多个子类实现了接口的情况。
    

通过引用数据类型的转换，就可以实现面向对象编程重要的特性之一多态，同一个父类类型的引用可以指向不同子类的实例，并根据实际对象的类型调用对应的方法。同时提高代码的复用性和灵活性。

## 运算符

### 算术运算符

执行基本的数学运算：加、减、乘、除和取余。

- `+` : 加法
- `-`: 减法
- `*`: 乘法
- `/` : 除法
- `%` : 取余数
- `++` 自增（前置和后置）
- `--` 自减（前置和后置）

在算术运算过程中，有两条需要注意的事项：

1. 小于`int`类型的数据类型将被自动提升为`int`类型，以确保运算的正确性和避免数据的溢出。
2. 小的数据类型和大的数据类型运算将会自动提升到大的数据类型。
3. 自增自减效果为加`1`或减`1`。
4. 前置为先操作再运算，后置位先运算再操作。

### 比较运算符

用于比较两个操作数之间的关系，结果为`boolean`类型，关系成立则为`true`，否则`false` 。

- `==` 等于
- `!=` 不等于
- `>` 大于
- `<` 小于
- `>=` 大于等于
- `<=` 小于等于

### 位运算符

用于对整数类型的操作数按位进行操作。

- `&` 按位与
- `|` 按位或
- `^` 按位异或
- `~` 按位取反
- `<<` 左移
- `>>` 右移
- `>>>` 无符号右移

说明：

1. `&`、`|`、`^`分别对两个操作数按位与、或和异或，高位补零。也可以进行逻辑运算。
    
2. `<<`将操作数所有位向左移动指定位数（右边补零），每向左移一位，相当于乘以 `2` 。
    
3. `>>`将操作数所有位向有移动指定位数（左边用符号位填充，正数补 `0`，负数补 `1`），每向右移一位，相当于除以 `2`。
    
4. 左移和右移是在二进制下，每移动一位都是在`2`的倍数上进行。
    
5. `>>>`将操作数的所有位向右移动指定的位数（左边总是用 `0` 填充）。这种方式不考虑符号位，主要用于处理无符号数。在Java中一般将整数定为`int`类型，`int`类型是`4`个字节`32`位，正数高位补`0`，负数高位补`1` 。
    
    ```jsx
    int a = -5; // 二进制：1111 1011（假设负数以补码形式表示）
    int result = a >>> 1; // 结果：0111 1101（实际32位），即 2147483645（忽略符号位进行移位）
    ```
    

### 逻辑运算符

用于布尔逻辑操作。

- `&&` /`&`逻辑与
- `||` /`|`逻辑或
- `!` 逻辑非

说明：

1. `&`和`|`对两个`boolean`类型进行逻辑与、或运算。也可以进行位运算。
2. `&&`和`||`作用和上面两个相同，但具有短路效果。

### 赋值运算符

用于给变量赋值或更新变量的值。

- `=` 赋值
- `+=` 加赋值
- `-=` 减赋值
- `*=` 乘赋值
- `/=` 除赋值
- `%=` 模赋值
- `&=` 按位与赋值
- `|=` 按位或赋值
- `^=` 按位异或赋值
- `<<=` 左移赋值
- `>>=` 右移赋值
- `>>>=` 无符号右移赋值
### 三元运算符

用于根据条件表达式返回不同的值。

- `?:` 条件运算符
    
    ```java
    关系表达式 ? 表达式1 : 表达式2;
    ```
    
    关系表达式成立（为`true`）返回表达式`1` 的结果，否则返回表达式`2` 的结果。
    

### 字符串拼接运算符

`+` 不但用于算术运算符，还可以用于字符串的拼接，如果是字符串与其它类型元素使用`+`，会自动转为字符串类型

### 类型转换运算符

用于将一种数据类型转换为另一种数据类型。

- `(type)` 类型转换，例如 `(int)`

### instanceof 运算符

用于检查对象是否是特定类或其子类的实例。

- `instanceof` 实例检查

# 流程控制语句

流程控制语句用来控制程序的执行顺序，程序默认从上往下顺序执行。

## 条件语句

条件语句是程序根据条件关系选择性的执行对应分支。

![[基础语法--9.png]]

### if-else语句

- **if 语句**：用于根据一个布尔表达式的结果来执行相应的代码块。
    
    ```java
    if (condition) {
        // 当条件为 true 时执行的代码
    }
    ```
    
- **if-else 语句**：当条件为 `true` 时执行 `if` 代码块，否则执行 `else` 代码块。
    
    ```java
    if (condition) {
        // 当条件为 true 时执行的代码
    } else {
        // 当条件为 false 时执行的代码
    }
    ```
    
- **if-else if-else 语句**：可以处理多个条件判断。
    
    ```java
    if (condition1) {
        // 当条件1为 true 时执行的代码
    } else if (condition2) {
        // 当条件2为 true 时执行的代码
    } else {
        // 当所有条件均为 false 时执行的代码
    }
    ```
    

### **switch 语句**

用于多重分支选择，根据表达式的值来执行相应的 `case` 代码块。

```java
switch (variable) {
    case value1:
        // 当 variable 等于 value1 时执行的代码
        break;
    case value2:
        // 当 variable 等于 value2 时执行的代码
        break;
    default:
        // 当没有匹配的 case 时执行的代码
        break;
}
```

## 循环语句

循环语句要求程序循环执行以达到边界条件。

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0536d6a3-c650-4e09-9e75-6d2605917d10/3f6323a4-336c-4b0a-8e53-b1fd255fb606/image.png)

### for循环

用于在已知执行次数的情况下重复执行某段代码。

```java
for (initialization; condition; update) {
    // 循环体
}
```

### while循环

- **while 循环**：在条件为 `true` 时重复执行某段代码。
    
    ```java
    while (condition) {
        // 循环体
    }
    ```
    
- **do-while 循环**：与 `while` 循环类似，但至少会执行一次循环体。
    
    ```java
    do {
        // 循环体
    } while (condition);
    ```
    

## 跳转语句

- **break 语句**：用于立即退出 `switch` 语句或循环。
    
    ```java
    break;
    ```
    
- **continue 语句**：用于跳过当前循环的剩余部分并进入下一次循环迭代。
    
    ```java
    continue;
    ```
    
- **return 语句**：用于从方法中返回。
    
    ```java
    return value; // 返回值可选，具体取决于方法的返回类型
    ```
    

# 数组

数组（Array）是一个存储相同类型元素的容器，数组在内存中是一段连续的的地址，可以通过索引（从0开始）访问每个元素。

## 数组的声明和初始化

### 声明

数组有两种定义方式：

- 指定类型和使用`[]`符号定义。
    
    ```jsx
    int[] array;//推荐使用这种
    ```
    
- 将`[]`符号放在变量名后面。
    
    ```jsx
    int array[];
    ```
    

### 初始化

- 静态初始化：在声明数组时的同时，直接分配内存并指定其元素
    
    ```jsx
    int[] numbers = {1, 2, 3, 4, 5};
    ```
    
- 动态初始化：先声明数组长度，然后再为数组添加元素。
    
    ```jsx
    int[] numbers = new int[5];
    numbers[0] = 1;
    numbers[1] = 2;
    ```
    

## 数组的基本操作

- **访问数组元素**：通过数组名和索引来访问或修改特定位置的元素。例如：`numbers[2]`表示访问`numbers`数组的第三个元素。
- **获取数组长度**：使用`array.length`属性获取数组的长度。例如：`numbers.length`。
- **排序**：使用`Arrays.sort(array)`对数组进行升序排序。
- **查找**：使用`Arrays.binarySearch(array, key)`来进行二分查找（前提是数组已排序）。
- **复制**：使用`Arrays.copyOf(array, newLength)`来复制数组。

## 多维数组

- **定义多维数组**：例如，二维数组可以被定义为`int[][] matrix = new int[3][3];`，表示一个3x3的二维数组。
    
- **初始化多维数组**：可以使用嵌套的花括号来静态初始化多维数组，例如：
    
    ```java
    int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    ```
    

## 数组的内存分配

数组在Java中是对象，在堆内存中分配空间。每个数组元素占用一段连续的内存空间。

## 数组和ArrayList比较

- 数组的大小是固定的，一旦声明，大小不能改变；ArrayList是动态数组，大小可以动态调整。
- 数组可以存储基本数据类型和对象，ArrayList只能存储对象。

## 数组的常见异常

- **ArrayIndexOutOfBoundsException**：当尝试访问数组的无效索引时抛出。
- **NullPointerException**：当数组未初始化而被访问时抛出。

## 数组的常用方法

- `Arrays.toString(array)`：将数组转换为字符串形式。
- `Arrays.equals(array1, array2)`：比较两个数组是否相等。

# 方法

方式（Method）是类或对象执行特定任务的代码块。

## 方法的定义

```java
[访问修饰符] [其他修饰符] 返回类型 方法名(参数列表) {
    // 方法体
}
```

- **访问修饰符**：例如 `public`, `private`, `protected`，决定方法的可访问性。
- **其他修饰符**：例如 `static`, `final`, `abstract`。
- **返回类型**：方法返回值的数据类型，如果没有返回值则为 `void`。
- **方法名**：标识方法的名称，应遵循驼峰命名法。
- **参数列表**：方法的输入参数，可为空。

## 方法的调用

- **实例方法调用**：需要创建对象，然后通过对象调用。
    
    ```java
    ClassName obj = new ClassName();
    obj.methodName();
    ```
    
- **静态方法调用**：可以通过类名直接调用，也可以通过对象调用。方法需要添加`static`修饰符。
    
    ```java
    ClassName.methodName();
    ```
    

## 参数传递

方法的参数传递涉及到形参和实参：

- 形参：方法定义中的参数列表
- 实参：在使用方法时传递给方法的参数

在Java中参数传递是**按值传递**的：

- 基本数据类型：传递的是值的副本
- 应用数据类型：传递的是对象引用的副本，方法内修改引用指向不会影响外部对象，但通过引用**修改对象内容**会影响外部对象。

## 可变长参数

## 返回类型

方法可以返回一个值或对象，返回类型必须与声明的一致。

- 使用 `return` 关键字返回值。
- `void` 方法不返回值，`return` 可以用于提前退出。

## 方法重载

同一个类中可以有多个方法名相同但参数列表不同的方法。

- 参数列表不同包括参数的类型、数量或顺序不同。
- 方法的返回类型可以相同也可以不同

## 方法重写

子类可以重写父类的方法，实现多态。

- 重写的方法必须具有相同的方法名、参数列表、返回类型。
- 重写的方法不能缩小访问权限。
- Java 提供 `@Override` 注解，用于标识这是一个重写的方法，编译器会检查方法的签名是否正确
- 被`final`修饰的方法不能被重写
- 多态仅适用于实例，静态方法和属性属于类，不能被重写

## 访问修饰符

访问修饰符用于控制类及其成员（变量和方法）的可见性。

- `public`：类、方法或变量对所有类可见。
- `protected`：类、方法或变量在同一个包内的类和任何子类中可见。
- `default`（无修饰符）：类、方法或变量仅在同一个包内可见。
- `private`：类、方法或变量仅在定义它们的类内可见。

|修饰符|同类中访问|同包中访问|子类中访问|跨包访问|
|---|---|---|---|---|
|`public`|✅|✅|✅|✅|
|`protected`|✅|✅|✅|❌|
|`default`|✅|✅|❌|❌|
|`private`|✅|❌|❌|❌|

## 静态方法

使用`static`修饰的方法，属于类而非某个实例。

- 可以直接使用类名进行调用
- 不能访问非静态成员变量或调用非静态方法。
- 通常用于不依赖于实例状态的工具类方法。
- 静态方法中不能访问实例变量或实例方法，静态方法在类加载时分配内存空间，而实例变量和实例方法依赖于对象的创建。
- 多态仅适用于实例，静态方法和属性属于类，不能被重写

## 抽象方法

只能在抽象类中定义，不包含方法体，子类必须重写。

```java
abstract class Animal {
    abstract void makeSound();
}
```

## 其它修饰符

- **`final`**：用来防止方法被子类重写。
- **`synchronized`**：用于线程同步，保证同一时间只有一个线程可以访问该方法。
- **`native`**：用于调用本地（非Java）代码。

在Java中，`final`关键字用于定义不可更改的常量或不可被继承的方法和类。当`final`修饰字段时，该字段就具有一些特殊的特性，使它的值在初始化后不可被改变。以下是Java中`final`修饰字段的特性和使用细节：

### 1. 一次性赋值

被`final`修饰的字段只能被赋值一次。对于实例变量和类变量，这意味着该变量的值一旦确定，就不能再被修改。

```java
java
Copy code
public class Example {
    private final int value = 42;
}

```

- 如果没有在定义时赋值，必须在**构造函数**中初始化`final`变量，否则会导致编译错误。
- 如果是静态`final`字段，则可以在**静态代码块**中赋值。

### 2. 常量池优化

对于**基本类型**和**不可变对象**，被`final`修饰的字段会在编译期被确定为常量，直接存储在类的常量池中。这意味着在编译后的字节码中，该值直接被内联到代码中，可以提高运行时的性能。

```java
java
Copy code
public class Example {
    private static final int CONSTANT_VALUE = 100;
    private final String NAME = "Maktub";
}

```

### 3. 用于构造不可变对象

`final`字段是实现**不可变对象**（如`String`、`Integer`等）的关键。通过将类中的字段设置为`final`，可以确保该字段在对象创建后不会被修改，从而实现不可变性。

```java
java
Copy code
public class ImmutableClass {
    private final String name;
    public ImmutableClass(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
}

```

### 4. 延迟初始化（Lazy Initialization）

`final`字段允许使用**延迟初始化**的方式，即在对象创建时不立刻赋值，而是在真正需要的时候才进行赋值。这种方式通常用于提高性能或减少内存占用。

```java
java
Copy code
public class LazyInitializationExample {
    private final int expensiveValue;

    public LazyInitializationExample() {
        // 一般的赋值可以放在构造函数中
        this.expensiveValue = calculateExpensiveValue();
    }

    private int calculateExpensiveValue() {
        // 计算开销较大的操作
        return 123;
    }
}

```

### 5. 多线程安全性

`final`字段在并发环境中具有内存可见性方面的优势。Java内存模型保证了在构造函数完成后，`final`字段对于所有线程都是可见的。也就是说，在一个线程中创建了一个包含`final`字段的对象后，其他线程可以直接读取这个字段，而不会看到未初始化的状态。

### 6. 静态常量（static final）

`static final`字段表示一个全局常量，它们通常是公共的，并且用大写字母命名。因为`static final`字段在类加载时就初始化完毕，并且无法修改，所以适合表示常量。

```java
java
Copy code
public class Constants {
    public static final double PI = 3.14159;
    public static final String VERSION = "1.0.0";
}

```

### 7. 引用类型的`final`字段

当`final`修饰的是**引用类型**的字段时，不能更改该引用的指向，但可以更改该引用指向的对象的内容。这就意味着，`final`字段仅保证了引用本身的不可变性，并不保证对象内部状态的不可变性。

```java
java
Copy code
public class Example {
    private final List<String> names = new ArrayList<>();

    public void addName(String name) {
        names.add(name); // 合法，可以修改List的内容
    }

    public void changeList() {
        // names = new ArrayList<>(); // 不合法，不能重新赋值
    }
}
```

### 8. 确保安全发布

`final`字段可以确保对象在多线程环境下的**安全发布**。在发布不可变对象或安全发布类的实例时，`final`字段可以防止其他线程访问到未完全构造的对象状态。















